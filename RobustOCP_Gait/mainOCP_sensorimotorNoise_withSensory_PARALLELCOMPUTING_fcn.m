function [] = mainOCP_sensorimotorNoise_withSensory_PARALLELCOMPUTING_fcn(saveName,IGName,diaryName,dt,sensoryNoise_continuousVAR,motorNoise_continuousVAR,D,T)

close all; clc;
import casadi.*

delete(diaryName);
%%% Generate time mesh %%%
% T = 0.5;
N = T/dt;
time = 0:dt:T;

% Noise settings
motorNoise_continuousVAR = motorNoise_continuousVAR; % Nm²s
motorNoise_discreteVAR = motorNoise_continuousVAR/dt; % Nm²
sensoryNoise_discreteVAR = sensoryNoise_continuousVAR/dt; % Nm²

% Parameters of the skeletal system
% m1 = 3.2; m5 = 3.2;
% m2 = 6.8; m4 = 6.8;
% m3 = 20;
% I1 = 0.93; I5 = 0.93;
% I2 = 1.08; I4 = 1.08;
% I3 = 2.22;
% l1 = 0.4; l5 = 0.4;
% l2 = 0.4; l4 = 0.4;
% l3 = 0.625;
% lc1 = l1 - 0.128; lc5 = lc1;
% lc2 = l2-0.163; lc4 = lc2;
% lc3 = 0.2;

m1 = 5; m5 = 5;
m2 = 9.3; m4 = 9.3;
m3 = 34;
I1 = 0.1; I5 = 0.1;
I2 = 0.14; I4 = 0.14;
I3 = 1.43
l1 = 0.45; l5 = 0.45;
l2 = 0.43; l4 = 0.43;
l3 = 0.625;
lc1 = 0.2; lc5 = 0.25;
lc2 = 0.22; lc4 = 0.21;
lc3 = 0.32;


g = 9.81;

% Number of states in the system
nStates = 10; % 5 joint positions, 5 joint velocities
nMNoiseSources = 5;
nSNoiseSources = 10;

%%% In this part we set up CasADi functions %%%

% Define CasADi variables that will serve as inputs to different functions

% Segment angles
q1_MX = MX.sym('q1_MX',1); q2_MX = MX.sym('q2_MX',1); q3_MX = MX.sym('q3_MX',1); q4_MX = MX.sym('q4_MX',1); q5_MX = MX.sym('q5_MX',1);
% Segment angular velocities
dq1_MX = MX.sym('dq1_MX',1); dq2_MX = MX.sym('dq2_MX',1); dq3_MX = MX.sym('dq3_MX',1); dq4_MX = MX.sym('dq4_MX',1); dq5_MX = MX.sym('dq5_MX',1);
% Derivatives of segment angles - slack control
u_MX = MX.sym('u_MX',5,1);
% Derivatives of segment angular velocities - slack control
ddq1_MX = MX.sym('ddq1_MX',1); ddq2_MX = MX.sym('ddq2_MX',1); ddq3_MX = MX.sym('ddq3_MX',1); ddq4_MX = MX.sym('ddq4_MX',1); ddq5_MX = MX.sym('ddq5_MX',1);
% Joint torques - 'real control'
T1_MX = MX.sym('T1_MX',1); T2_MX = MX.sym('T2_MX',1); T3_MX = MX.sym('T3_MX',1); T4_MX = MX.sym('T4_MX',1); T5_MX = MX.sym('T5_MX',1);
% Reference trajectory - The trajectory in a deterministic environment generated by feedforward control. - slack control
refTraj_MX = MX.sym('refTraj_MX',10,1);
% Feedback gains - 'real' control
K_MX = MX.sym('K_MX',5,10);
% Derivatives of state derivative to the state
udx_MX = MX.sym('udx_MX',nStates,nStates);
% Derivatives of state derivative to the noise sources (5 - one motor noise source at each joint)
udw_MX = MX.sym('udw_MX',nStates,5);
udwS_MX = MX.sym('udwS_MX',nStates,10);
% Noise sourcers
w1_MX = MX.sym('w1_MX',1); w2_MX = MX.sym('w2_MX',1); w3_MX = MX.sym('w3_MX',1); w4_MX = MX.sym('w4_MX',1); w5_MX = MX.sym('w5_MX',1);
% Sensory noise sourcers
wS1_MX = MX.sym('wS1_MX',1); wS2_MX = MX.sym('wS2_MX',1); wS3_MX = MX.sym('wS3_MX',1); wS4_MX = MX.sym('wS4_MX',1); wS5_MX = MX.sym('wS5_MX',1);
wS6_MX = MX.sym('wS6_MX',1); wS7_MX = MX.sym('wS7_MX',1); wS8_MX = MX.sym('wS8_MX',1); wS9_MX = MX.sym('wS9_MX',1); wS10_MX = MX.sym('wS10_MX',1);

% Generate different CasADi functions

% Implicit skeletal dynamics (only feedforward control ~ NOMINAL control)
eq_SysDyn_Error_Nominal = eq_SysDyn(I1,I2,I3,I4,I5,T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
f_eq_SysDyn_Error_Nominal = Function('f_eq_SysDyn_Error_Nominal',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX},{eq_SysDyn_Error_Nominal});

% Implicit stochastic skeletal dynamics (only feedforward control ; but with uncertainty added)

% Relative segment angles (joint angles) and velocities (joint angular velocities)
relativeJointPos_MX = relativeJointPos(q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
relativeJointVel_MX = relativeJointVel(dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX);

feedbackTransform = [1  0 0 0 0 0 0 0 0 0;...
                     1 -1 0 0 0 0 0 0 0 0;...
                     0 1 -1 0 0 0 0 0 0 0;...
                     0 0 -1 1 0 0 0 0 0 0;...
                     0 0 0 -1 1 0 0 0 0 0;...
                     0 0 0 0 0 1  0 0 0 0;...
                     0 0 0 0 0 1 -1 0 0 0;...
                     0 0 0 0 0 0 1 -1 0 0;...
                     0 0 0 0 0 0 0 -1 1 0;...
                     0 0 0 0 0 0 0 0 -1 1];
                     

% Sensory feedback signal:: joint position and velocities relative to
% reference trajectory
kinFB_MX = [relativeJointPos_MX; relativeJointVel_MX] - refTraj_MX;
T_FB_MX = K_MX*kinFB_MX;
T1_FF_FB_MX = T_FB_MX(1) + T1_MX;
T2_FF_FB_MX = T_FB_MX(2) + T2_MX;
T3_FF_FB_MX = T_FB_MX(3) + T3_MX;
T4_FF_FB_MX = T_FB_MX(4) + T4_MX;
T5_FF_FB_MX = T_FB_MX(5) + T5_MX;

% Implicit skeletal dynamics (feedback + feedforward control ~ ROBUST control) - is a function of the reference trajectory and feedback gains  as well
eq_SysDyn_Error = eq_SysDyn(I1,I2,I3,I4,I5,T1_FF_FB_MX,T2_FF_FB_MX,T3_FF_FB_MX,T4_FF_FB_MX,T5_FF_FB_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX)
f_eq_SysDyn_Error = Function('f_eq_SysDyn_Error',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX},{eq_SysDyn_Error});

% Formulate implicit state dynamics with slack variables
kinFB_W_MX = [relativeJointPos_MX; relativeJointVel_MX] - refTraj_MX + [wS1_MX;wS2_MX;wS3_MX;wS4_MX;wS5_MX;wS6_MX;wS7_MX;wS8_MX;wS9_MX;wS10_MX ];
T_FB_W_MX = K_MX*kinFB_W_MX;
T1_FF_FB_W_MX = T_FB_W_MX(1) + T1_MX;
T2_FF_FB_W_MX = T_FB_W_MX(2) + T2_MX;
T3_FF_FB_W_MX = T_FB_W_MX(3) + T3_MX;
T4_FF_FB_W_MX = T_FB_W_MX(4) + T4_MX;
T5_FF_FB_W_MX = T_FB_W_MX(5) + T5_MX;
eq_SysDynW_Error = eq_SysDyn(I1,I2,I3,I4,I5,T1_FF_FB_W_MX+w1_MX,T2_FF_FB_W_MX+w2_MX,T3_FF_FB_W_MX+w3_MX,T4_FF_FB_W_MX+w4_MX,T5_FF_FB_W_MX+w5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
eq_SysDyn_Error_extended = [[u_MX - [dq1_MX; dq2_MX; dq3_MX; dq4_MX; dq5_MX]] ; eq_SysDyn_Error];
eq_SysDynW_Error_extended = [[u_MX - [dq1_MX; dq2_MX; dq3_MX; dq4_MX; dq5_MX]] ; eq_SysDynW_Error];

% Derivative of the implicit state dynamics with slack variables to the state variables (apply the chain rule to bring in the derivatives of state derivative to the state)
eq_SysDynDer_Error = jacobian(eq_SysDyn_Error_extended, [q1_MX q2_MX q3_MX q4_MX q5_MX dq1_MX dq2_MX dq3_MX dq4_MX dq5_MX]) + jacobian(eq_SysDyn_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udx_MX;
f_dynamicsDerivativeError = Function('f_dynamicsDerivativeError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udx_MX},{reshape(eq_SysDynDer_Error(6:10,:),50,1)});

% Derivative of the implicit state dynamics with slack variables to the noise sources (apply the chain rule to bring in the derivatives of state derivative to the noise sources)
eq_SysDynDerW_Error = jacobian(eq_SysDynW_Error_extended, [w1_MX w2_MX w3_MX w4_MX w5_MX]) + jacobian(eq_SysDynW_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udw_MX;
f_dynamicsDerivativeWError = Function('f_dynamicsDerivativeWError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udw_MX},{reshape(eq_SysDynDerW_Error(6:10,:),25,1)});

% Derivative of the implicit state dynamics with slack variables to the noise sources (apply the chain rule to bring in the derivatives of state derivative to the noise sources)
eq_SysDynDerWS_Error = jacobian(eq_SysDynW_Error_extended, [wS1_MX wS2_MX wS3_MX wS4_MX wS5_MX wS6_MX wS7_MX wS8_MX wS9_MX wS10_MX]) + jacobian(eq_SysDynW_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udwS_MX;
f_dynamicsDerivativeWSError = Function('f_dynamicsDerivativeWSError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udwS_MX},{reshape(eq_SysDynDerWS_Error(6:10,:),50,1)});


% Foot clearance
P_J_MX = JointPos(l1,l2,l3,l4,l5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
footClearance_MX = P_J_MX(10);
dfootClearance_dX_MX = jacobian(footClearance_MX,[q1_MX q2_MX q3_MX q4_MX q5_MX]);
f_dfootClearance_dX_MX = Function('f_dfootClearance_dX_MX',{q1_MX, q2_MX, q3_MX, q4_MX, q5_MX},{dfootClearance_dX_MX});

% Scaling of our variables
q_scale = ones(5,1);
dq_scale = ones(5,1);
ddq_scale = 10*ones(5,1);
T_scale = 10*ones(5,1);
K_scale = 100*ones(5,10);
refTraj_scale = ones(10,1);
udw_scale = ones(5,5);
udwS_scale = ones(5,10);
udx_scale = 10*ones(5,10);

% dynamicsError = implicitDynamicsMuscles_ff(e_ff_MX,a_MX,q_MX,qdot_MX,u_MX,auxdata); % Only feedforward dynamics are necessary for nominal part of the OCP
constr_par = [vertcat(eq_SysDyn_Error_Nominal{:})./ddq_scale; reshape(eq_SysDynDer_Error(6:10,:),50,1)./udx_scale(1:50)'; reshape(eq_SysDynDerW_Error(6:10,:),25,1)./udw_scale(1:25)';reshape(eq_SysDynDerWS_Error(6:10,:),50,1)./udwS_scale(1:50)'];%];

% Set-up a function to generate this one constraint vector (that will need to be imposed every integration interval)
f_par_constr = Function('f_par_constr',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udx_MX,udw_MX,udwS_MX},{constr_par}); 

udz_MX = MX.sym('udz_MX',nStates,nStates);
M_MX =  MX.sym('M_MX',nStates,nStates);
dGdz_MX = dGdz(udz_MX,dt);
constr_par2 = M_MX*dGdz_MX - eye(10);
f_par_constr2 = Function('f_par_constr2',{M_MX,udz_MX},{constr_par2}); 
    
    
%% ROBUST OPTIMAL CONTROL

% Get indices to easily go from a vector form to matrix form for the
% covariance matrix
indicesP = NaN(10,10);
vecindicesP = NaN(55,1);
ct = 1;
for i = 1:10
    for j = i:10
        vecindicesP(ct,1) = (i-1)*10+j;
        indicesP(i,j) = ct;
        ct = ct + 1;
    end
end
for i = 1:9
    for j = i+1:10
        indicesP(j,i) = indicesP(i,j);
    end
end

varianceIndices = diag(indicesP);
covarianceIndices = 1:55;
covarianceIndices(varianceIndices) = [];

% Load an exemplary controller that works well for this system
load(IGName);

q1_guess = result.q1_sol; q2_guess = result.q2_sol; q3_guess = result.q3_sol; q4_guess = result.q4_sol; q5_guess = result.q5_sol;
dq1_guess = result.dq1_sol; dq2_guess = result.dq2_sol; dq3_guess = result.dq3_sol; dq4_guess = result.dq4_sol; dq5_guess = result.dq5_sol;
ddq1_guess = result.ddq1_sol; ddq2_guess = result.ddq2_sol; ddq3_guess = result.ddq3_sol; ddq4_guess = result.ddq4_sol; ddq5_guess = result.ddq5_sol;
T1_guess = result.T1_sol; T2_guess = result.T2_sol; T3_guess = result.T3_sol; T4_guess = result.T4_sol; T5_guess = result.T5_sol;
refTraj_guess = result.refTraj_sol;
K_guess = result.K_sol;
udx_guess = result.udx_sol;
udw_guess = result.udw_sol;
udwS_guess = result.udwS_sol;
L_guess = result.L_sol;
M_guess = result.M_sol;
L_precontact_guess = result.L_precontact_sol;
L_postcontact_guess = result.L_postcontact_sol;
L_sigma_postcontact_guess = result.sigma_postcontact_sol;

% Interpolate the initial guess on optimization mesh
% time_orig = 0:0.03125*0.8/0.5:0.8;
time_orig = 0:0.01:0.8;

time_optimization = 0:dt:T;
q1_guess = spline(time_orig,q1_guess,time_optimization); q2_guess = spline(time_orig,q2_guess,time_optimization); q3_guess = spline(time_orig,q3_guess,time_optimization); q4_guess = spline(time_orig,q4_guess,time_optimization); q5_guess = spline(time_orig,q5_guess,time_optimization);
dq1_guess = spline(time_orig,dq1_guess,time_optimization); dq2_guess = spline(time_orig,dq2_guess,time_optimization); dq3_guess = spline(time_orig,dq3_guess,time_optimization); dq4_guess = spline(time_orig,dq4_guess,time_optimization); dq5_guess = spline(time_orig,dq5_guess,time_optimization);
ddq1_guess = spline(time_orig,ddq1_guess,time_optimization); ddq2_guess = spline(time_orig,ddq2_guess,time_optimization); ddq3_guess = spline(time_orig,ddq3_guess,time_optimization); ddq4_guess = spline(time_orig,ddq4_guess,time_optimization); ddq5_guess = spline(time_orig,ddq5_guess,time_optimization);
T1_guess = spline(time_orig,T1_guess,time_optimization); T2_guess = spline(time_orig,T2_guess,time_optimization); T3_guess = spline(time_orig,T3_guess,time_optimization); T4_guess = spline(time_orig,T4_guess,time_optimization); T5_guess = spline(time_orig,T5_guess,time_optimization);
refTraj_guess = spline(time_orig,refTraj_guess,time_optimization);
L_guess = spline(time_orig,L_guess,time_optimization);
% L_guess(varianceIndices,:) = 1e-2;
% L_guess(covarianceIndices,:) = 0;

K_guess_orig = K_guess; udx_guess_orig = udx_guess; udw_guess_orig = udw_guess; M_guess_orig = M_guess; udwS_guess_orig = udwS_guess; 
K_guess = NaN(5,10*(N+1)); udx_guess = NaN(10,10*(N+1)); udw_guess = NaN(10,5*(N+1)); M_guess = NaN(10,10*N);
for j = 1:nStates
    K_guess(:,j:nStates:end) = spline(time_orig,K_guess_orig(:,j:nStates:end),time_optimization);
    udx_guess(:,j:nStates:end) = spline(time_orig,udx_guess_orig(:,j:nStates:end),time_optimization);
    M_guess(:,j:nStates:end) = spline(time_orig(1:end-1),M_guess_orig(:,j:nStates:end),time_optimization(1:end-1));

end

for j = 1:nMNoiseSources
    udw_guess(:,j:nMNoiseSources:end) = spline(time_orig,udw_guess_orig(:,j:nMNoiseSources:end),time_optimization);
end

for j = 1:nSNoiseSources
    udwS_guess(:,j:nSNoiseSources:end) = spline(time_orig,udwS_guess_orig(:,j:nSNoiseSources:end),time_optimization);
end

J_guess_effort = (sumsqr(T1_guess) + sumsqr(T2_guess) + sumsqr(T3_guess) + sumsqr(T4_guess) + sumsqr(T5_guess))*dt;% 
J_guess_expectedEffort = NaN(33,1);
for k = 1:N+1
    Lk = L_guess(:,k);
     Lmatk = tril(ones(10)).*Lk(indicesP);
    Pmatk = Lmatk*Lmatk';
    Kk = K_guess(:,(k-1)*10+1:10*k);
J_guess_expectedEffort(k) = sum(diag((Kk*feedbackTransform)*Pmatk*(Kk*feedbackTransform)'))*dt;
end



Lscale = [0.01*ones(5,1) ; 0.05*ones(5,1)].*tril(ones(10)); Lscale_vec = Lscale(vecindicesP);
Pscale = Lscale*Lscale'; Pscale_vec = Pscale(vecindicesP);

% Generate robust problem
opti_robust = casadi.Opti(); % Create opti instance
q1 = q_scale(1)*opti_robust.variable(1,N+1);   q2 = q_scale(2)*opti_robust.variable(1,N+1);   q3 = q_scale(3)*opti_robust.variable(1,N+1);   q4 = q_scale(4)*opti_robust.variable(1,N+1); , q5 = q_scale(5)*opti_robust.variable(1,N+1);
dq1 = dq_scale(1)*opti_robust.variable(1,N+1);  dq2 = dq_scale(2)*opti_robust.variable(1,N+1);  dq3 = dq_scale(3)*opti_robust.variable(1,N+1);  dq4 = dq_scale(4)*opti_robust.variable(1,N+1);  dq5 = dq_scale(5)*opti_robust.variable(1,N+1);
ddq1 = ddq_scale(1)*opti_robust.variable(1,N+1);   ddq2 = ddq_scale(2)*opti_robust.variable(1,N+1);   ddq3 = ddq_scale(3)*opti_robust.variable(1,N+1);   ddq4 = ddq_scale(4)*opti_robust.variable(1,N+1);   ddq5 = ddq_scale(5)*opti_robust.variable(1,N+1);
T1 = T_scale(1)*opti_robust.variable(1,N+1);     T2 = T_scale(2)*opti_robust.variable(1,N+1);     T3 = T_scale(3)*opti_robust.variable(1,N+1);     T4 = T_scale(4)*opti_robust.variable(1,N+1);     T5 = T_scale(5)*opti_robust.variable(1,N+1);




refTraj = refTraj_scale.*opti_robust.variable(10,(N+1));
opti_robust.set_initial(refTraj,refTraj_guess);

K = repmat(K_scale,1,N+1).*opti_robust.variable(5,10*(N+1));
opti_robust.set_initial(K,K_guess);
% opti_robust.subject_to(K(:) == 0);

udx = repmat(udx_scale,1,N+1).*opti_robust.variable(10,10*(N+1));
opti_robust.set_initial(udx,udx_guess);
for i = 1:N + 1
    opti_robust.subject_to(udx(1:5,(i-1)*10+1:i*10 - 5) == 0);
    opti_robust.subject_to(udx(1:5,(i-1)*10+6:i*10) - eye(5) == 0);
end
M = opti_robust.variable(10,10*N); 
    opti_robust.subject_to(-50 < M(:) < 50);

opti_robust.set_initial(M,M_guess);


L = Lscale_vec.*opti_robust.variable(55,N+1);
Lvar = L(varianceIndices,:);
opti_robust.subject_to(Lvar(:)>0);
opti_robust.set_initial(L,L_guess);

udw = repmat(udw_scale,1,N+1).*opti_robust.variable(10,5*(N+1));
opti_robust.set_initial(udw,udw_guess);
opti_robust.subject_to(udw(1:5,:) == 0);

udwS = repmat(udwS_scale,1,N+1).*opti_robust.variable(10,10*(N+1));
opti_robust.set_initial(udwS,udwS_guess);

% Urf = MX.sym('Urf',10*21);
% sigma_post_guess = reshape(Urf,10,21);
% 
% for k = 1:N+1
%     
%     Kk_guess = K_guess(:,(k-1)*10+1:k*10);
% rf = rootfinder('rf','newton',struct('x',Urf,'g',f_dynamicsDerivativeWSError(T1_guess(k),T2_guess(k),T3_guess(k),T4_guess(k),T5_guess(k),ddq1_guess(k),ddq2_guess(k),ddq3_guess(k),ddq4_guess(k),ddq5_guess(k),dq1_guess(k),dq2_guess(k),dq3_guess(k),dq4_guess(k),dq5_guess(k),q1_guess(k),q2_guess(k),q3_guess(k),q4_guess(k),q5_guess(k),refTraj_guess(:,k),Kk_guess,u_MX,udwS_MX),struct('abstol',1e-6));
% 
% end

                                
                                
                                
opti_robust.subject_to(udwS(1:5,:) == 0);

% Crude bounds on the segment orientations
opti_robust.subject_to(-pi/2 < q1 < pi/2);
opti_robust.subject_to(-pi/2 < q2 < pi/2);
opti_robust.subject_to(-pi/3 < q3 < pi/3);
opti_robust.subject_to(-pi/2 < q4 < pi/2);
opti_robust.subject_to(-pi/2 < q5 < pi/2);

% Physiological joint limits
opti_robust.subject_to(-pi < q1 - q2 < 0); % Knee joint limit
opti_robust.subject_to(-pi < q5 - q4 < 0); % Knee joint limit


% Use initial guess from nominal solution and forward solution of P,udx
% time_original = 1;
% clear result
% if exist('result')
opti_robust.set_initial(q1, q1_guess);
opti_robust.set_initial(q2, q2_guess);
opti_robust.set_initial(q3, q3_guess);
opti_robust.set_initial(q4, q4_guess);
opti_robust.set_initial(q5, q5_guess);

opti_robust.set_initial(dq1, dq1_guess);
opti_robust.set_initial(dq2, dq2_guess);
opti_robust.set_initial(dq3, dq3_guess);
opti_robust.set_initial(dq4, dq4_guess);
opti_robust.set_initial(dq5, dq5_guess);

opti_robust.set_initial(ddq1, ddq1_guess);
opti_robust.set_initial(ddq2, ddq2_guess);
opti_robust.set_initial(ddq3, ddq3_guess);
opti_robust.set_initial(ddq4, ddq4_guess);
opti_robust.set_initial(ddq5, ddq5_guess);

opti_robust.set_initial(T1, T1_guess);
opti_robust.set_initial(T2, T2_guess);
opti_robust.set_initial(T3, T3_guess);
opti_robust.set_initial(T4, T4_guess);
opti_robust.set_initial(T5, T5_guess);
    

% Generate heel-strike map (periodicity for swing vs stance leg + impulsive
% collision constraint) 
% WE DEAL WITH THIS USING A Unscented Transform of the HEELSTRIKE MAP
% q1_min = q1(:,end); q2_min = q2(:,end); q3_min = q3(:,end); q4_min = q4(:,end); q5_min = q5(:,end);
% q1_plus = q1(:,1); q2_plus = q2(:,1); q3_plus = q3(:,1); q4_plus = q4(:,1); q5_plus = q5(:,1);
% dq1_min = dq1(:,end); dq2_min = dq2(:,end); dq3_min = dq3(:,end); dq4_min = dq4(:,end); dq5_min = dq5(:,end);
% dq1_plus = dq1(:,1); dq2_plus = dq2(:,1); dq3_plus = dq3(:,1); dq4_plus = dq4(:,1); dq5_plus = dq5(:,1);
% heelStrike_error = eq_HeelStrike(I1,I2,I3,I4,I5,dq1_min,dq2_min,dq3_min,dq4_min,dq5_min,dq1_plus,dq2_plus,dq3_plus,dq4_plus,dq5_plus,l1,l2,l4,l5,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_min,q2_min,q3_min,q4_min,q5_min,q1_plus,q2_plus,q3_plus,q4_plus,q5_plus)



f_par_constr_map = f_par_constr.map(N+1,'thread',4);
par_constr = f_par_constr_map(T1,T2,T3,T4,T5,ddq1,ddq2,ddq3,ddq4,ddq5,dq1,dq2,dq3,dq4,dq5,q1,q2,q3,q4,q5,refTraj,K,[dq1;dq2;dq3;dq4;dq5],udx,udw,udwS);
opti_robust.subject_to(par_constr==0);

f_par_constr2_map = f_par_constr2.map(N,'thread',4);
par_constr2 = f_par_constr2_map(M,udx(:,nStates+1:end));
opti_robust.subject_to(par_constr2==0);

J = 0;

for k=1:N+1
    % State at mesh point k
    q1k = q1(:,k);     q2k = q2(:,k);     q3k = q3(:,k);     q4k = q4(:,k);     q5k = q5(:,k);
    dq1k = dq1(:,k);   dq2k = dq2(:,k);   dq3k = dq3(:,k);   dq4k = dq4(:,k);   dq5k = dq5(:,k);
    
    % Control/ for mesh k
    ddq1k = ddq1(:,k); ddq2k = ddq2(:,k); ddq3k = ddq3(:,k); ddq4k = ddq4(:,k); ddq5k = ddq5(:,k);
    T1k = T1(:,k);     T2k = T2(:,k);     T3k = T3(:,k);     T4k = T4(:,k);     T5k = T5(:,k);  

    
    % Feedback variables
    refTrajk = refTraj(:,k);
    Kk = K(:,(k-1)*10+1:10*k);
    
    relativeJointPosk = relativeJointPos(q1k,q2k,q3k,q4k,q5k);
    relativeJointVelk = relativeJointVel(dq1k,dq2k,dq3k,dq4k,dq5k);
    opti_robust.subject_to((refTrajk - [relativeJointPosk; relativeJointVelk])./refTraj_scale == 0);
    

    % Cost function contributions
    J = J + (T1k.^2 + T2k.^2 + T3k.^2 + T4k.^2 + T5k.^2)*dt;% 
    
    % Joint locations in x-y plane
    P_J = JointPos(l1,l2,l3,l4,l5,q1k,q2k,q3k,q4k,q5k);
    
    % Impose that swing foot does not penetrate ground
    opti_robust.subject_to(P_J(10) > -1e-8);
        
end


for k=1:N
    % State at mesh point k
    q1k = q1(:,k);     q2k = q2(:,k);     q3k = q3(:,k);     q4k = q4(:,k);     q5k = q5(:,k);
    dq1k = dq1(:,k);   dq2k = dq2(:,k);   dq3k = dq3(:,k);   dq4k = dq4(:,k);   dq5k = dq5(:,k);
    
    % Control/ for mesh k
    ddq1k = ddq1(:,k); ddq2k = ddq2(:,k); ddq3k = ddq3(:,k); ddq4k = ddq4(:,k); ddq5k = ddq5(:,k);
    ddq1k_plus = ddq1(:,k+1); ddq2k_plus = ddq2(:,k+1); ddq3k_plus = ddq3(:,k+1); ddq4k_plus = ddq4(:,k+1); ddq5k_plus = ddq5(:,k+1);
    
    % State at mesh point k+1
    q1k_plus = q1(:,k+1);     q2k_plus = q2(:,k+1);     q3k_plus = q3(:,k+1);     q4k_plus = q4(:,k+1);     q5k_plus = q5(:,k+1);
    dq1k_plus = dq1(:,k+1);   dq2k_plus = dq2(:,k+1);   dq3k_plus = dq3(:,k+1);   dq4k_plus = dq4(:,k+1);   dq5k_plus = dq5(:,k+1);
    
    % Collect state
    Xk = [q1k; q2k; q3k; q4k; q5k; dq1k; dq2k; dq3k; dq4k; dq5k];
    Xk_next = [q1k_plus; q2k_plus; q3k_plus; q4k_plus; q5k_plus; dq1k_plus; dq2k_plus; dq3k_plus; dq4k_plus; dq5k_plus];
    
    % Collect state derivative
    Uk = [dq1k; dq2k; dq3k; dq4k; dq5k; ddq1k; ddq2k; ddq3k; ddq4k; ddq5k];
    Uk_plus = [dq1k_plus; dq2k_plus; dq3k_plus; dq4k_plus; dq5k_plus; ddq1k_plus; ddq2k_plus; ddq3k_plus; ddq4k_plus; ddq5k_plus];
    
    % Integration (trapezoidal)
    opti_robust.subject_to((Xk_next - (Xk + (Uk + Uk_plus)*dt/2))./[q_scale;dq_scale] == 0);
  

    Kk = K(:,(k-1)*10+1:10*k);
        
    udxk = udx(:,(k-1)*10 + 1:k*10);
    udwk = udw(:,(k-1)*5 + 1:k*5);
    udwSk = udwS(:,(k-1)*10 + 1:k*10);

    udzk = udx(:,k*10 + 1 : (k+1)*10);

    Mk = M(:,(k-1)*10 + 1:k*10);
    dGdz_ = dGdz(udzk,dt);
    dGdx_ = dGdx(udxk,dt);
    dGdw_ = dGdw(udwk,dt);
    dGdwS_ = dGdw(udwSk,dt);

    
%     opti_robust.subject_to(Mk*dGdz_ - eye(10) == 0);
    
    Lk = L(:,k);
    Lmatk = tril(ones(10)).*Lk(indicesP);
    Pmatk = Lmatk*Lmatk';

    Lk_plus = L(:,k+1);
    Lmatk_plus = tril(ones(10)).*Lk_plus(indicesP);
    Pmatk_plus_ = Lmatk_plus*Lmatk_plus';
    Pveck_plus = Pmatk_plus_(vecindicesP);
 
    Pmatk_plus = Mk*(dGdx_*Pmatk*dGdx_' + dGdw_*motorNoise_discreteVAR*eye(5)*dGdw_'  + dGdwS_*(sensoryNoise_discreteVAR.*eye(10))*dGdwS_')*Mk';
    Pk_plus = Pmatk_plus(vecindicesP);
    opti_robust.subject_to((Pk_plus - Pveck_plus)./Pscale(vecindicesP) == 0);   
    
    expected_effortk = sum(diag((Kk*feedbackTransform)*Pmatk*(Kk*feedbackTransform)')) + sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'));
    J = J + expected_effortk*dt + 0*1e2*sumsqr(diag(Pmatk));
    
    % Foot clearance during midstance
    if k > 0.1*N && k < 0.9*N
        k
        P_J = JointPos(l1,l2,l3,l4,l5,q1k,q2k,q3k,q4k,q5k);
        footClearance = P_J(10);
        dfootClearance_dX = f_dfootClearance_dX_MX(q1k,q2k,q3k,q4k,q5k);
        opti_robust.subject_to((footClearance^2 - 9*dfootClearance_dX*Pmatk(1:5,1:5)*dfootClearance_dX')*1e3 > 0);
    end
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Constrain the contact variability
%% UT of contact %%%
nStates = 10;
nNoiseSources = 0;
nTOT = nStates + nNoiseSources;
% nTOT = 0;

alpha = 1; % --> determines the spread of the sigma points -- influence on c! a small value means a small spread around the mean in sigma selection. Has an influence on selection of the posterior covariance
kappa = 3-nTOT; % Scales the spread of the sigma points as well, often 3-n is chosen, but this can generate some problems with positive definitness
beta = 2; % Is a parameter to incorporate prior knowledge on distribution, only affects the weights to compose the posterior covariance matrix
% If alpha = 1 and kappa = 0 you get the basic implementation of the UKF.
kappa = 0;
% Note that Julier commented in the paper (unscented ...) that non-positive
% weights for predicted covariance can lead to non-positive definitness
kappa = -6;
lambda = alpha^2*(nTOT + kappa) - nTOT;

W_0_M = lambda/(nTOT+lambda);
W_i_M = 1/(2*(nTOT+lambda));
W_0_C = lambda/(nTOT+lambda) + 1 - alpha^2 + beta;
W_i_C = 1/(2*(nTOT+lambda));

WeightVec_M = [W_0_M W_i_M*ones(1,2*(nTOT))]; 
WeightVec_C = [W_0_C W_i_C*ones(1,2*(nTOT))];
c = sqrt(nTOT+lambda);

L_precontact = Lscale_vec.*opti_robust.variable(55,1);
opti_robust.subject_to(L_precontact(varianceIndices) > 0)
Lguess_precontact = result.L_precontact_sol;
Lguess_mat_precontact = Lguess_precontact(indicesP);
opti_robust.set_initial(L_precontact,Lguess_precontact);

L_postcontact = Lscale_vec.*opti_robust.variable(55,1);
opti_robust.subject_to(L_postcontact(varianceIndices) > 0)

sigma_postcontact = opti_robust.variable(10,2*nTOT + 1);
L_precontact_mat = tril(ones(10,10)).*L_precontact(indicesP);


mean_precontact_guess = [result.q1_sol(:,end); result.q2_sol(:,end); result.q3_sol(:,end); result.q4_sol(:,end); result.q5_sol(:,end); result.dq1_sol(:,end); result.dq2_sol(:,end); result.dq3_sol(:,end); result.dq4_sol(:,end); result.dq5_sol(:,end)];

sigma_precontact_guess = [mean_precontact_guess      mean_precontact_guess + c*Lguess_mat_precontact      mean_precontact_guess - c*Lguess_mat_precontact];

% P_precontact = P(:,k+1);
% P_precontact_mat = P_precontact(indicesP);

Lk = L(:,k+1);
Lmatk = tril(ones(10)).*Lk(indicesP);
P_precontact_mat = Lmatk*Lmatk';
    
opti_robust.subject_to(diag(L_precontact_mat) > 0);   
opti_robust.subject_to((Lk - L_precontact)./(Lscale_vec) == 0);  
A_precontact = c*L_precontact_mat;
Xk_precontact = Xk_next;

sigma_precontact = [Xk_precontact Xk_precontact + A_precontact Xk_precontact - A_precontact];

Urf = MX.sym('Urf',10*21);
sigma_post_guess = reshape(Urf,10,21);
rf = rootfinder('rf','newton',struct('x',Urf,'g',reshape(eq_HeelStrike(I1,I2,I3,I4,I5,sigma_precontact_guess(6,:),sigma_precontact_guess(7,:),sigma_precontact_guess(8,:),sigma_precontact_guess(9,:),sigma_precontact_guess(10,:),sigma_post_guess(6,:),sigma_post_guess(7,:),sigma_post_guess(8,:),sigma_post_guess(9,:),sigma_post_guess(10,:),l1,l2,l4,l5,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,...
                                    sigma_precontact_guess(1,:),sigma_precontact_guess(2,:),sigma_precontact_guess(3,:),sigma_precontact_guess(4,:),sigma_precontact_guess(5,:)...
                                    ,sigma_post_guess(1,:),sigma_post_guess(2,:),sigma_post_guess(3,:),sigma_post_guess(4,:),sigma_post_guess(5,:)),210,1)),struct('abstol',1e-6));

eq_heelstrikeError = eq_HeelStrike(I1,I2,I3,I4,I5,sigma_precontact(6,:),sigma_precontact(7,:),sigma_precontact(8,:),sigma_precontact(9,:),sigma_precontact(10,:),sigma_postcontact(6,:),sigma_postcontact(7,:),sigma_postcontact(8,:),sigma_postcontact(9,:),sigma_postcontact(10,:),l1,l2,l4,l5,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,...
                                    sigma_precontact(1,:),sigma_precontact(2,:),sigma_precontact(3,:),sigma_precontact(4,:),sigma_precontact(5,:)...
                                    ,sigma_postcontact(1,:),sigma_postcontact(2,:),sigma_postcontact(3,:),sigma_postcontact(4,:),sigma_postcontact(5,:));
opti_robust.subject_to(eq_heelstrikeError == 0);                                
                                
solution = rf(reshape(result.sigma_postcontact_sol,210,1),[]);
sigma_post_contact_guess = reshape(full(solution),10,21);
    
opti_robust.set_initial(sigma_postcontact,result.sigma_postcontact_sol);

   

mean_postcontact = sigma_postcontact*WeightVec_M';
opti_robust.subject_to(mean_postcontact - [q1(:,1); q2(:,1); q3(:,1); q4(:,1); q5(:,1); dq1(:,1); dq2(:,1); dq3(:,1); dq4(:,1); dq5(:,1);] == 0);
    
Y1k = sigma_postcontact - mean_postcontact;
P_postcontact_mat = Y1k*diag(WeightVec_C)*Y1k' + 1e-8*eye(10);
L_postcontact_mat = tril(ones(10,10)).*L_postcontact(indicesP);

P_postcontact_mat_estimated = L_postcontact_mat*L_postcontact_mat';
P_postcontact_vec_estimated = P_postcontact_mat_estimated(vecindicesP);
opti_robust.subject_to((P_postcontact_mat_estimated(vecindicesP) - P_postcontact_mat(vecindicesP))./Pscale_vec == 0)
P_postcontact_estimated = P_postcontact_mat_estimated(vecindicesP);
% J = J + 1e8*sum(sum(P_postcontact_estimated(varianceIndices,:)))*dt;

mean_postcontact_guess = sigma_post_contact_guess*WeightVec_M';
    
Y1k = sigma_post_contact_guess - mean_postcontact_guess;
P_postcontact_guess_mat = Y1k*diag(WeightVec_C)*Y1k' + 1e-8*eye(10);
Lguess_postcontact_guess = chol(P_postcontact_guess_mat)';
Lguess_postcontact_guess_vec = Lguess_postcontact_guess(vecindicesP);
opti_robust.set_initial(L_postcontact,result.L_postcontact_sol);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Kk = K(:,(k)*10+1:10*(k+1));
expected_effortk = sum(diag((Kk*feedbackTransform)*Pmatk_plus_*(Kk*feedbackTransform)')) +  sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'));
J = J + expected_effortk*dt;

% Periodicity constraint (part is in the heel strike map)
JointPosFinal = JointPos(l1,l2,l3,l4,l5,q1(:,end),q2(:,end),q3(:,end),q4(:,end),q5(:,end));
opti_robust.subject_to(JointPosFinal(9:10,:) - [D;0] == 0); %  Impose step length of 1 meter (1.2)

% Impose that simulation start and end is at 'toe-off' and 'heel-strike'
JointVelInit = JointVel(dq1(:,1),dq2(:,1),dq3(:,1),dq4(:,1),dq5(:,1),l1,l2,l3,l4,l5,q1(:,1),q2(:,1),q3(:,1),q4(:,1),q5(:,1));
JointVelFinal = JointVel(dq1(:,end),dq2(:,end),dq3(:,end),dq4(:,end),dq5(:,end),l1,l2,l3,l4,l5,q1(:,end),q2(:,end),q3(:,end),q4(:,end),q5(:,end));
opti_robust.subject_to(JointVelInit(10) > 0);
opti_robust.subject_to(JointVelFinal(10) < 0);

Pscale_diag = diag(Pscale);
initVarPos = Pscale_diag(1:5).*opti_robust.variable(5,1);
opti_robust.subject_to(10 > initVarPos > 1e-5);
opti_robust.set_initial(initVarPos,result.initVarPos_sol);
initVarVel = Pscale_diag(6:10).*opti_robust.variable(5,1);
opti_robust.subject_to(10 > initVarVel > 1e-5);
opti_robust.set_initial(initVarVel,result.initVarVel_sol);

L_init_vec = L(:,1);
L_init_matk = tril(ones(10)).*L_init_vec(indicesP);
P_init_matk = L_init_matk*L_init_matk';
P_initRel_matk = feedbackTransform*P_init_matk*feedbackTransform';
P_init_vec = P_init_matk(vecindicesP);
P_initRel_vec = P_initRel_matk(vecindicesP);

initCovar = Pscale_vec(covarianceIndices).*opti_robust.variable(45,1); 
opti_robust.set_initial(initCovar,result.initCovar_sol);

opti_robust.subject_to((P_init_vec(varianceIndices(1:5),1) - initVarPos)./Pscale_diag(1:5) == 0);
opti_robust.subject_to((P_init_vec(varianceIndices(6:10),1) - initVarVel)./Pscale_diag(6:10) == 0);
opti_robust.subject_to((P_init_vec(covarianceIndices,1) - initCovar)./Pscale_vec(covarianceIndices) == 0);

P_helper_vec = zeros(55,1);


L_final_vec = L(:,end);
L_final_matk = tril(ones(10)).*L_final_vec(indicesP);
P_final_matk = L_final_matk*L_final_matk';
P_finalRel_matk = feedbackTransform*P_final_matk*feedbackTransform';
P_final_vec = P_final_matk(vecindicesP);
P_finalRel_vec = P_finalRel_matk(vecindicesP);

% Periodicity constraints

% opti_robust.subject_to([T2(end) - T5(1); T3(end) - T4(1);  T4(end) - T3(1);   T5(end) - T2(1)] == 0); 

Kinit = K(:,1:10);
Kfinal = K(:,N*10+1:10*(N+1));
% opti_robust.subject_to([Kfinal(2,:) - Kinit(5,:); Kfinal(3,:) - Kinit(4,:);   Kfinal(4,:) - Kinit(3,:);   Kfinal(5,:) - Kinit(2,:)] == 0); 


opti_robust.subject_to((P_postcontact_estimated(varianceIndices) - [initVarPos;initVarVel])./Pscale_diag == 0);
opti_robust.subject_to((P_postcontact_estimated(covarianceIndices) - [initCovar])./Pscale_vec(covarianceIndices) == 0);




% Define cost
% J = J + 1e-6*sumsqr(udx/100) + 1e-6*sumsqr(udw/100) + 1e-6*sumsqr(M/100) + 1e-6*sumsqr(L/100) + 1e-6*sumsqr(L_precontact_mat/100) + 1e-6*sumsqr(L_postcontact_mat/100);
opti_robust.minimize(1e-3*J);

% opti_robust.callback(@(i) opti_robust.debug.show_infeasibilities(1));


% Create an NLP solver
optionssol.ipopt.linear_solver = 'mumps';
% optionssol.ipopt.print_level = 6;

optionssol.ipopt.tol = 1e-4;

optionssol.ipopt.constr_viol_tol = 1e-6;

optionssol.ipopt.max_iter = 1e5;
optionssol.ipopt.nlp_scaling_method = 'none';
% optionssol.ipopt.hessian_approximation = 'limited-memory';
optionssol.ipopt.mu_strategy = 'adaptive';
optionssol.ipopt.bound_push = 1e-5;
optionssol.ipopt.required_infeasibility_reduction = 0.999999;
% optionssol.ipopt.print_level = 6;
opti_robust.solver('ipopt',optionssol);

diary(diaryName);
sol = opti_robust.solve();
% output = solve_NLPSOL(opti_robust,optionssol);
diary off;
index = 1;
clear result;
q1_sol = q_scale(1).*output(index:index + N)'; index = index + N + 1; result.q1_sol = q1_sol;
q2_sol = q_scale(2).*output(index:index + N)'; index = index + N + 1; result.q2_sol = q2_sol;
q3_sol = q_scale(3).*output(index:index + N)'; index = index + N + 1; result.q3_sol = q3_sol;
q4_sol = q_scale(4).*output(index:index + N)'; index = index + N + 1; result.q4_sol = q4_sol;
q5_sol = q_scale(5).*output(index:index + N)'; index = index + N + 1; result.q5_sol = q5_sol;

dq1_sol = dq_scale(1).*output(index:index + N)'; index = index + N + 1; result.dq1_sol = dq1_sol;
dq2_sol = dq_scale(2).*output(index:index + N)'; index = index + N + 1; result.dq2_sol = dq2_sol;
dq3_sol = dq_scale(3).*output(index:index + N)'; index = index + N + 1; result.dq3_sol = dq3_sol;
dq4_sol = dq_scale(4).*output(index:index + N)'; index = index + N + 1; result.dq4_sol = dq4_sol;
dq5_sol = dq_scale(5).*output(index:index + N)'; index = index + N + 1; result.dq5_sol = dq5_sol;

ddq1_sol = ddq_scale(1).*output(index:index + N)'; index = index + N + 1; result.ddq1_sol = ddq1_sol;
ddq2_sol = ddq_scale(2).*output(index:index + N)'; index = index + N + 1; result.ddq2_sol = ddq2_sol;
ddq3_sol = ddq_scale(3).*output(index:index + N)'; index = index + N + 1; result.ddq3_sol = ddq3_sol;
ddq4_sol = ddq_scale(4).*output(index:index + N)'; index = index + N + 1; result.ddq4_sol = ddq4_sol;
ddq5_sol = ddq_scale(5).*output(index:index + N)'; index = index + N + 1; result.ddq5_sol = ddq5_sol;

T1_sol = T_scale(1).*output(index:index + N)'; index = index + N + 1; result.T1_sol = T1_sol;
T2_sol = T_scale(2).*output(index:index + N)'; index = index + N + 1; result.T2_sol = T2_sol;
T3_sol = T_scale(3).*output(index:index + N)'; index = index + N + 1; result.T3_sol = T3_sol;
T4_sol = T_scale(4).*output(index:index + N)'; index = index + N + 1; result.T4_sol = T4_sol;
T5_sol = T_scale(5).*output(index:index + N)'; index = index + N + 1; result.T5_sol = T5_sol;


refTraj_sol = refTraj_scale.*reshape(output(index:index + 10*(N+1) - 1),10,N+1); index = index + 10*(N + 1); result.refTraj_sol = refTraj_sol;

K_sol = repmat(K_scale,1,N+1).*reshape(output(index:index + 5*10*(N+1) - 1),5,10*(N+1)); index = index + 5*10*(N + 1); result.K_sol = K_sol;

udx_sol = repmat(udx_scale,1,N+1).*reshape(output(index: index + 10*10*(N+1) - 1),10,10*(N+1)); index = index + 10*10*(N + 1); result.udx_sol = udx_sol;

M_sol = reshape(output(index: index + 10*10*N - 1),10,10*N); index = index + 10*10*N; result.M_sol = M_sol;

L_sol = Lscale_vec.*reshape(output(index: index + 55*(N+1) - 1),55,N+1); index = index + 55*(N + 1); result.L_sol = L_sol;

udw_sol = repmat(udw_scale,1,N+1).*reshape(output(index: index + 10*5*(N+1) - 1),10,5*(N+1)); index = index + 10*5*(N + 1); result.udw_sol = udw_sol;

udwS_sol =  repmat(udwS_scale,1,N+1).*reshape(output(index: index + 10*10*(N+1) - 1),10,10*(N+1));  index = index + 10*10*(N + 1); result.udwS_sol = udwS_sol;

L_precontact_sol = Lscale(vecindicesP).*output(index: index + 55 - 1); index = index + 55; result.L_precontact_sol = L_precontact_sol;

L_postcontact_sol = Lscale(vecindicesP).*output(index: index + 55 - 1); index = index + 55; result.L_postcontact_sol = L_postcontact_sol;

sigma_postcontact_sol = reshape(output(index: index + 10*21 - 1),10,21); index = index + 10*21; result.sigma_postcontact_sol = sigma_postcontact_sol;

initVarPos_sol = Pscale_diag(1:5).*output(index:index + 5 - 1); index = index + 5; result.initVarPos_sol = initVarPos_sol;

initVarVel_sol = Pscale_diag(6:10).*output(index:index + 5 - 1); index = index + 5; result.initVarVel_sol = initVarVel_sol;

initCovar_sol = Pscale_vec(covarianceIndices).*output(index:index + 45 - 1); index = index + 45; result.initCovar_sol = initCovar_sol;







% sol = opti_robust.solve();
% diary off

% q1_sol = sol.value(q1); result.q1_sol = q1_sol;
% q2_sol = sol.value(q2); result.q2_sol = q2_sol;
% q3_sol = sol.value(q3); result.q3_sol = q3_sol;
% q4_sol = sol.value(q4); result.q4_sol = q4_sol;
% q5_sol = sol.value(q5); result.q5_sol = q5_sol;
% 
% dq1_sol = sol.value(dq1); result.dq1_sol = dq1_sol;
% dq2_sol = sol.value(dq2); result.dq2_sol = dq2_sol;
% dq3_sol = sol.value(dq3); result.dq3_sol = dq3_sol;
% dq4_sol = sol.value(dq4); result.dq4_sol = dq4_sol;
% dq5_sol = sol.value(dq5); result.dq5_sol = dq5_sol;
% 
% T1_sol = sol.value(T1); result.T1_sol = T1_sol;
% T2_sol = sol.value(T2); result.T2_sol = T2_sol;
% T3_sol = sol.value(T3); result.T3_sol = T3_sol;
% T4_sol = sol.value(T4); result.T4_sol = T4_sol;
% T5_sol = sol.value(T5); result.T5_sol = T5_sol;
% 
% ddq1_sol = sol.value(ddq1); result.ddq1_sol = ddq1_sol;
% ddq2_sol = sol.value(ddq2); result.ddq2_sol = ddq2_sol;
% ddq3_sol = sol.value(ddq3); result.ddq3_sol = ddq3_sol;
% ddq4_sol = sol.value(ddq4); result.ddq4_sol = ddq4_sol;
% ddq5_sol = sol.value(ddq5); result.ddq5_sol = ddq5_sol;
% 
% refTraj_sol = sol.value(refTraj); result.refTraj_sol = refTraj_sol;
% K_sol = sol.value(K); result.K_sol = K_sol;
% 
% L_sol = sol.value(L); result.L_sol = L_sol;
% 
% initVarPos_sol = sol.value(initVarPos); result.initVarPos_sol = initVarPos_sol;
% initVarVel_sol = sol.value(initVarVel); result.initVarVel_sol = initVarVel_sol;
% 
% udx_sol = sol.value(udx); result.udx_sol = udx_sol;
% udw_sol = sol.value(udw); result.udw_sol = udw_sol;
% M_sol = sol.value(M); result.M_sol = M_sol;
% result.L_postcontact_sol = sol.value(L_postcontact); L_postcontact_sol = sol.value(L_postcontact); 


cost_expectedEffort = 0;
for k = 1:N+1
    Lvec_sol = L_sol(:,k);
    Lmat_sol = tril(ones(10)).*Lvec_sol(indicesP);
    Pmat_sol = Lmat_sol*Lmat_sol';
    Pvec_sol(:,k) = Pmat_sol(vecindicesP);
    Kk = K_sol(:,(k-1)*10+1:10*k);
    cost_expectedEffort = cost_expectedEffort + sum(diag((Kk*feedbackTransform)*Pmat_sol*(Kk*feedbackTransform)'))*dt;
    T_std(:,k) = sqrt(diag((Kk*feedbackTransform)*Pmat_sol*(Kk*feedbackTransform)'));
    q_std(:,k) = sqrt(diag(Pmat_sol(1:5,1:5)));
    dq_std(:,k) = sqrt(diag(Pmat_sol(6:10,6:10)));

    [~,flag] = chol(Pmat_sol);
    flag
end

result.P_sol = Pvec_sol;
result.J_torque = (sumsqr(T1_sol) + sumsqr(T2_sol) + sumsqr(T3_sol) + sumsqr(T4_sol) + sumsqr(T5_sol))*dt;
result.J_expectedEffort = cost_expectedEffort;

[ipoptStats.CPU_IPOPT,ipoptStats.CPU_NLP,ipoptStats.NIter,ipoptStats.Cost,ipoptStats.Dual_inf,ipoptStats.Cons_Viol,ipoptStats.Compl,ipoptStats.Error_NLP,ipoptStats.OptSol] = readDiary(diaryName);
result.ipoptStats = ipoptStats;
result.motorNoise_continuousVAR = motorNoise_continuousVAR;
result.sensoryNoise_continuousVAR = sensoryNoise_continuousVAR;

save(saveName,'result')



