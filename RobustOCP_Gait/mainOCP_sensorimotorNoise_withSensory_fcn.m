function [] = mainOCP_sensorimotorNoise_withSensory_fcn(saveName,IGName,diaryName,dt,sensoryNoise_continuousVAR,motorNoise_continuousVAR,D,T)

close all; clc;
import casadi.*

delete(diaryName);
%%% Generate time mesh %%%
% T = 0.5;
N = T/dt;
time = 0:dt:T;

% Noise settings - change the continuous noise variance to the discrete equivalent value
motorNoise_discreteVAR = motorNoise_continuousVAR/dt; % Nm².s --> Nm²
sensoryNoise_discreteVAR = sensoryNoise_continuousVAR/dt; % angular positions: rad².s --> rad² --  angular velocities: (rad/s)²/s --> (rad/s)²

% Parameters of the skeletal system
% ~based on OpenSim2354
m1 = 5; m5 = 5;
m2 = 9.3; m4 = 9.3;
m3 = 34;
I1 = 0.1; I5 = 0.1;
I2 = 0.14; I4 = 0.14;
I3 = 1.43;
l1 = 0.45; l5 = 0.45;
l2 = 0.43; l4 = 0.43;
l3 = 0.625;
lc1 = 0.2; lc5 = 0.25;
lc2 = 0.22; lc4 = 0.21;
lc3 = 0.32;

g = 9.81;

% Number of states in the system
nStates = 10; % 5 joint positions, 5 joint velocities
nMNoiseSources = 5; % independent motor noise at each joint torque
nSNoiseSources = 10; % independent sensory noise at each feedback signal (angular positions/velocities)

%%% In this part we set up CasADi functions %%%

% Define CasADi variables that will serve as inputs to different functions

% Segment angles
q1_MX = MX.sym('q1_MX',1); q2_MX = MX.sym('q2_MX',1); q3_MX = MX.sym('q3_MX',1); q4_MX = MX.sym('q4_MX',1); q5_MX = MX.sym('q5_MX',1);
% Segment angular velocities
dq1_MX = MX.sym('dq1_MX',1); dq2_MX = MX.sym('dq2_MX',1); dq3_MX = MX.sym('dq3_MX',1); dq4_MX = MX.sym('dq4_MX',1); dq5_MX = MX.sym('dq5_MX',1);
% Derivatives of segment angles - slack control
u_MX = MX.sym('u_MX',5,1);
% Derivatives of segment angular velocities - slack control
ddq1_MX = MX.sym('ddq1_MX',1); ddq2_MX = MX.sym('ddq2_MX',1); ddq3_MX = MX.sym('ddq3_MX',1); ddq4_MX = MX.sym('ddq4_MX',1); ddq5_MX = MX.sym('ddq5_MX',1);
% Joint torques - 'real control'
T1_MX = MX.sym('T1_MX',1); T2_MX = MX.sym('T2_MX',1); T3_MX = MX.sym('T3_MX',1); T4_MX = MX.sym('T4_MX',1); T5_MX = MX.sym('T5_MX',1);
% Reference trajectory - The trajectory in a deterministic environment generated by feedforward control. - slack control
refTraj_MX = MX.sym('refTraj_MX',10,1);
% Feedback gains - 'real' control
K_MX = MX.sym('K_MX',5,10);
% Derivatives of state derivative to the state
udx_MX = MX.sym('udx_MX',nStates,nStates);
% Derivatives of state derivative to the noise sources (5 - one motor noise source at each joint; 10 sensory noise)
udw_MX = MX.sym('udw_MX',nStates,5);
udwS_MX = MX.sym('udwS_MX',nStates,10);
% Noise sourcers
w1_MX = MX.sym('w1_MX',1); w2_MX = MX.sym('w2_MX',1); w3_MX = MX.sym('w3_MX',1); w4_MX = MX.sym('w4_MX',1); w5_MX = MX.sym('w5_MX',1);
% Sensory noise sources
wS1_MX = MX.sym('wS1_MX',1); wS2_MX = MX.sym('wS2_MX',1); wS3_MX = MX.sym('wS3_MX',1); wS4_MX = MX.sym('wS4_MX',1); wS5_MX = MX.sym('wS5_MX',1);
wS6_MX = MX.sym('wS6_MX',1); wS7_MX = MX.sym('wS7_MX',1); wS8_MX = MX.sym('wS8_MX',1); wS9_MX = MX.sym('wS9_MX',1); wS10_MX = MX.sym('wS10_MX',1);

% Generate different CasADi functions

% Implicit skeletal dynamics (only feedforward control ~ NOMINAL control)
eq_SysDyn_Error_Nominal = eq_SysDyn(I1,I2,I3,I4,I5,T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
f_eq_SysDyn_Error_Nominal = Function('f_eq_SysDyn_Error_Nominal',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX},{eq_SysDyn_Error_Nominal});


% Relative segment angles (joint angles) and velocities (joint angular velocities)
relativeJointPos_MX = relativeJointPos(q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
relativeJointVel_MX = relativeJointVel(dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX);
       

% Sensory feedback signal:: joint position and velocities relative to
% reference trajectory
kinFB_MX = [relativeJointPos_MX; relativeJointVel_MX] - refTraj_MX;
T_FB_MX = K_MX*kinFB_MX;
T1_FF_FB_MX = T_FB_MX(1) + T1_MX;
T2_FF_FB_MX = T_FB_MX(2) + T2_MX;
T3_FF_FB_MX = T_FB_MX(3) + T3_MX;
T4_FF_FB_MX = T_FB_MX(4) + T4_MX;
T5_FF_FB_MX = T_FB_MX(5) + T5_MX;

% Implicit skeletal dynamics (feedback + feedforward control ~ ROBUST control) - is a function of the reference trajectory and feedback gains  as well!!
eq_SysDyn_Error = eq_SysDyn(I1,I2,I3,I4,I5,T1_FF_FB_MX,T2_FF_FB_MX,T3_FF_FB_MX,T4_FF_FB_MX,T5_FF_FB_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
f_eq_SysDyn_Error = Function('f_eq_SysDyn_Error',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX},{eq_SysDyn_Error});

% Formulate implicit state dynamics with slack variables
kinFB_W_MX = [relativeJointPos_MX; relativeJointVel_MX] - refTraj_MX + [wS1_MX;wS2_MX;wS3_MX;wS4_MX;wS5_MX;wS6_MX;wS7_MX;wS8_MX;wS9_MX;wS10_MX ];
T_FB_W_MX = K_MX*kinFB_W_MX;
T1_FF_FB_W_MX = T_FB_W_MX(1) + T1_MX;
T2_FF_FB_W_MX = T_FB_W_MX(2) + T2_MX;
T3_FF_FB_W_MX = T_FB_W_MX(3) + T3_MX;
T4_FF_FB_W_MX = T_FB_W_MX(4) + T4_MX;
T5_FF_FB_W_MX = T_FB_W_MX(5) + T5_MX;
eq_SysDynW_Error = eq_SysDyn(I1,I2,I3,I4,I5,T1_FF_FB_W_MX+w1_MX,T2_FF_FB_W_MX+w2_MX,T3_FF_FB_W_MX+w3_MX,T4_FF_FB_W_MX+w4_MX,T5_FF_FB_W_MX+w5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,g,l1,l2,l4,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
eq_SysDyn_Error_extended = [[u_MX - [dq1_MX; dq2_MX; dq3_MX; dq4_MX; dq5_MX]] ; eq_SysDyn_Error];
eq_SysDynW_Error_extended = [[u_MX - [dq1_MX; dq2_MX; dq3_MX; dq4_MX; dq5_MX]] ; eq_SysDynW_Error];

% Derivative of the implicit state dynamics with slack variables to the state variables (apply the chain rule to bring in the derivatives of state derivative to the state)
eq_SysDynDer_Error = jacobian(eq_SysDyn_Error_extended, [q1_MX q2_MX q3_MX q4_MX q5_MX dq1_MX dq2_MX dq3_MX dq4_MX dq5_MX]) + jacobian(eq_SysDyn_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udx_MX;
f_dynamicsDerivativeError = Function('f_dynamicsDerivativeError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udx_MX},{reshape(eq_SysDynDer_Error(6:10,:),50,1)});

% Derivative of the implicit state dynamics with slack variables to the motor noise sources (apply the chain rule to bring in the derivatives of state derivative to the motor noise sources)
eq_SysDynDerW_Error = jacobian(eq_SysDynW_Error_extended, [w1_MX w2_MX w3_MX w4_MX w5_MX]) + jacobian(eq_SysDynW_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udw_MX;
f_dynamicsDerivativeWError = Function('f_dynamicsDerivativeWError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udw_MX},{reshape(eq_SysDynDerW_Error(6:10,:),25,1)});

% Derivative of the implicit state dynamics with slack variables to the sensory noise sources (apply the chain rule to bring in the derivatives of state derivative to the sensory noise sources)
eq_SysDynDerWS_Error = jacobian(eq_SysDynW_Error_extended, [wS1_MX wS2_MX wS3_MX wS4_MX wS5_MX wS6_MX wS7_MX wS8_MX wS9_MX wS10_MX]) + jacobian(eq_SysDynW_Error_extended, [ u_MX' ddq1_MX ddq2_MX ddq3_MX ddq4_MX ddq5_MX])*udwS_MX;
f_dynamicsDerivativeWSError = Function('f_dynamicsDerivativeWSError',{T1_MX,T2_MX,T3_MX,T4_MX,T5_MX,ddq1_MX,ddq2_MX,ddq3_MX,ddq4_MX,ddq5_MX,dq1_MX,dq2_MX,dq3_MX,dq4_MX,dq5_MX,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX,refTraj_MX,K_MX,u_MX,udwS_MX},{reshape(eq_SysDynDerWS_Error(6:10,:),50,1)});


% Foot clearance
P_J_MX = JointPos(l1,l2,l3,l4,l5,q1_MX,q2_MX,q3_MX,q4_MX,q5_MX);
footClearance_MX = P_J_MX(10);
dfootClearance_dX_MX = jacobian(footClearance_MX,[q1_MX q2_MX q3_MX q4_MX q5_MX]);
f_dfootClearance_dX_MX = Function('f_dfootClearance_dX_MX',{q1_MX, q2_MX, q3_MX, q4_MX, q5_MX},{dfootClearance_dX_MX});


%% ROBUST OPTIMAL CONTROL

% Get indices to easily go from a vector form to matrix form for the
% covariance matrix
indicesP = NaN(10,10);
vecindicesP = NaN(55,1);
ct = 1;
for i = 1:10
    for j = i:10
        vecindicesP(ct,1) = (i-1)*10+j;
        indicesP(i,j) = ct;
        ct = ct + 1;
    end
end
for i = 1:9
    for j = i+1:10
        indicesP(j,i) = indicesP(i,j);
    end
end

varianceIndices = diag(indicesP);
covarianceIndices = 1:55;
covarianceIndices(varianceIndices) = [];

% Load an initial guess controller 
load(IGName);

q1_guess = result.q1_sol; q2_guess = result.q2_sol; q3_guess = result.q3_sol; q4_guess = result.q4_sol; q5_guess = result.q5_sol;
dq1_guess = result.dq1_sol; dq2_guess = result.dq2_sol; dq3_guess = result.dq3_sol; dq4_guess = result.dq4_sol; dq5_guess = result.dq5_sol;
ddq1_guess = result.ddq1_sol; ddq2_guess = result.ddq2_sol; ddq3_guess = result.ddq3_sol; ddq4_guess = result.ddq4_sol; ddq5_guess = result.ddq5_sol;
T1_guess = result.T1_sol; T2_guess = result.T2_sol; T3_guess = result.T3_sol; T4_guess = result.T4_sol; T5_guess = result.T5_sol;
refTraj_guess = result.refTraj_sol;
K_guess = result.K_sol;
udx_guess = result.udx_sol;
udw_guess = result.udw_sol;
udwS_guess = result.udwS_sol;
L_guess = result.L_sol;
M_guess = result.M_sol;
L_precontact_guess = result.L_precontact_sol;
L_postcontact_guess = result.L_postcontact_sol;
L_sigma_postcontact_guess = result.sigma_postcontact_sol;

% Interpolate the initial guess on optimization mesh
time_orig = 0:0.01:0.8;

time_optimization = 0:dt:T;
q1_guess = spline(time_orig,q1_guess,time_optimization); q2_guess = spline(time_orig,q2_guess,time_optimization); q3_guess = spline(time_orig,q3_guess,time_optimization); q4_guess = spline(time_orig,q4_guess,time_optimization); q5_guess = spline(time_orig,q5_guess,time_optimization);
dq1_guess = spline(time_orig,dq1_guess,time_optimization); dq2_guess = spline(time_orig,dq2_guess,time_optimization); dq3_guess = spline(time_orig,dq3_guess,time_optimization); dq4_guess = spline(time_orig,dq4_guess,time_optimization); dq5_guess = spline(time_orig,dq5_guess,time_optimization);
ddq1_guess = spline(time_orig,ddq1_guess,time_optimization); ddq2_guess = spline(time_orig,ddq2_guess,time_optimization); ddq3_guess = spline(time_orig,ddq3_guess,time_optimization); ddq4_guess = spline(time_orig,ddq4_guess,time_optimization); ddq5_guess = spline(time_orig,ddq5_guess,time_optimization);
T1_guess = spline(time_orig,T1_guess,time_optimization); T2_guess = spline(time_orig,T2_guess,time_optimization); T3_guess = spline(time_orig,T3_guess,time_optimization); T4_guess = spline(time_orig,T4_guess,time_optimization); T5_guess = spline(time_orig,T5_guess,time_optimization);
refTraj_guess = spline(time_orig,refTraj_guess,time_optimization);
L_guess = spline(time_orig,L_guess,time_optimization);

K_guess_orig = K_guess; udx_guess_orig = udx_guess; udw_guess_orig = udw_guess; M_guess_orig = M_guess; udwS_guess_orig = udwS_guess; 
K_guess = NaN(5,10*(N+1)); udx_guess = NaN(10,10*(N+1)); udw_guess = NaN(10,5*(N+1)); M_guess = NaN(10,10*N);
for j = 1:nStates
    K_guess(:,j:nStates:end) = spline(time_orig,K_guess_orig(:,j:nStates:end),time_optimization);
    udx_guess(:,j:nStates:end) = spline(time_orig,udx_guess_orig(:,j:nStates:end),time_optimization);
    M_guess(:,j:nStates:end) = spline(time_orig(1:end-1),M_guess_orig(:,j:nStates:end),time_optimization(1:end-1));

end

for j = 1:nMNoiseSources
    udw_guess(:,j:nMNoiseSources:end) = spline(time_orig,udw_guess_orig(:,j:nMNoiseSources:end),time_optimization);
end

for j = 1:nSNoiseSources
    udwS_guess(:,j:nSNoiseSources:end) = spline(time_orig,udwS_guess_orig(:,j:nSNoiseSources:end),time_optimization);
end


% Matrix to transform the states (segment angles) to relative joint angles
feedbackTransform = [1  0 0 0 0 0 0 0 0 0;...
                     1 -1 0 0 0 0 0 0 0 0;...
                     0 1 -1 0 0 0 0 0 0 0;...
                     0 0 -1 1 0 0 0 0 0 0;...
                     0 0 0 -1 1 0 0 0 0 0;...
                     0 0 0 0 0 1  0 0 0 0;...
                     0 0 0 0 0 1 -1 0 0 0;...
                     0 0 0 0 0 0 1 -1 0 0;...
                     0 0 0 0 0 0 0 -1 1 0;...
                     0 0 0 0 0 0 0 0 -1 1];
              
			  
% Scaling of our variables
q_scale = ones(5,1);
dq_scale = ones(5,1);
ddq_scale = 10*ones(5,1);
T_scale = 10*ones(5,1);
K_scale = 100*ones(5,10);
refTraj_scale = ones(10,1);
udw_scale = ones(10,5);
udwS_scale = ones(10,10);

Lscale = [0.01*ones(5,1) ; 0.05*ones(5,1)].*tril(ones(10)); Lscale_vec = Lscale(vecindicesP);
Pscale = Lscale*Lscale'; Pscale_vec = Pscale(vecindicesP);
udx_scale = 10*ones(10,10);

% Generate robust problem
opti_robust = casadi.Opti(); % Create opti instance
q1 = q_scale(1)*opti_robust.variable(1,N+1);   q2 = q_scale(2)*opti_robust.variable(1,N+1);   q3 = q_scale(3)*opti_robust.variable(1,N+1);   q4 = q_scale(4)*opti_robust.variable(1,N+1); , q5 = q_scale(5)*opti_robust.variable(1,N+1);
dq1 = dq_scale(1)*opti_robust.variable(1,N+1);  dq2 = dq_scale(2)*opti_robust.variable(1,N+1);  dq3 = dq_scale(3)*opti_robust.variable(1,N+1);  dq4 = dq_scale(4)*opti_robust.variable(1,N+1);  dq5 = dq_scale(5)*opti_robust.variable(1,N+1);
ddq1 = ddq_scale(1)*opti_robust.variable(1,N+1);   ddq2 = ddq_scale(2)*opti_robust.variable(1,N+1);   ddq3 = ddq_scale(3)*opti_robust.variable(1,N+1);   ddq4 = ddq_scale(4)*opti_robust.variable(1,N+1);   ddq5 = ddq_scale(5)*opti_robust.variable(1,N+1);
T1 = T_scale(1)*opti_robust.variable(1,N+1);     T2 = T_scale(2)*opti_robust.variable(1,N+1);     T3 = T_scale(3)*opti_robust.variable(1,N+1);     T4 = T_scale(4)*opti_robust.variable(1,N+1);     T5 = T_scale(5)*opti_robust.variable(1,N+1);


refTraj = refTraj_scale.*opti_robust.variable(10,(N+1));
opti_robust.set_initial(refTraj,refTraj_guess);

K = repmat(K_scale,1,N+1).*opti_robust.variable(5,10*(N+1));
opti_robust.set_initial(K,K_guess);
% opti_robust.subject_to(K(:) == 0);

udx = repmat(udx_scale,1,N+1).*opti_robust.variable(10,10*(N+1));
opti_robust.set_initial(udx,udx_guess);
for i = 1:N + 1
    opti_robust.subject_to(udx(1:5,(i-1)*10+1:i*10 - 5) == 0);
    opti_robust.subject_to(udx(1:5,(i-1)*10+6:i*10) - eye(5) == 0);
end
M = opti_robust.variable(10,10*N); 
opti_robust.subject_to(-50 < M(:) < 50); % Avoid problematic region for the trapezoidal integration of the Lyapunov dynamics
opti_robust.set_initial(M,M_guess);


L = Lscale_vec.*opti_robust.variable(55,N+1);
Lvar = L(varianceIndices,:);
opti_robust.subject_to(Lvar(:)>0);
opti_robust.set_initial(L,L_guess);

udw = repmat(udw_scale,1,N+1).*opti_robust.variable(10,5*(N+1));
opti_robust.set_initial(udw,udw_guess);
opti_robust.subject_to(udw(1:5,:) == 0); % Apply prior knowledge (derivative of the position is independent on the motor noise), these variables will be deleted from the problem

udwS = repmat(udwS_scale,1,N+1).*opti_robust.variable(10,10*(N+1));
opti_robust.set_initial(udwS,udwS_guess);                  
opti_robust.subject_to(udwS(1:5,:) == 0); % Apply prior knowledge (derivative of the position is independent on the sensory noise), these variables will be deleted from the problem

% Crude bounds on the segment orientations
opti_robust.subject_to(-pi/2 < q1 < pi/2);
opti_robust.subject_to(-pi/2 < q2 < pi/2);
opti_robust.subject_to(-pi/3 < q3 < pi/3);
opti_robust.subject_to(-pi/2 < q4 < pi/2);
opti_robust.subject_to(-pi/2 < q5 < pi/2);

% Physiological joint limits
opti_robust.subject_to(-pi < q1 - q2 < 0); % Knee joint limit
opti_robust.subject_to(-pi < q5 - q4 < 0); % Knee joint limit


% Use initial guess from nominal solution and forward solution of P,udx
% time_original = 1;
% clear result
% if exist('result')
opti_robust.set_initial(q1, q1_guess);
opti_robust.set_initial(q2, q2_guess);
opti_robust.set_initial(q3, q3_guess);
opti_robust.set_initial(q4, q4_guess);
opti_robust.set_initial(q5, q5_guess);

opti_robust.set_initial(dq1, dq1_guess);
opti_robust.set_initial(dq2, dq2_guess);
opti_robust.set_initial(dq3, dq3_guess);
opti_robust.set_initial(dq4, dq4_guess);
opti_robust.set_initial(dq5, dq5_guess);

opti_robust.set_initial(ddq1, ddq1_guess);
opti_robust.set_initial(ddq2, ddq2_guess);
opti_robust.set_initial(ddq3, ddq3_guess);
opti_robust.set_initial(ddq4, ddq4_guess);
opti_robust.set_initial(ddq5, ddq5_guess);

opti_robust.set_initial(T1, T1_guess);
opti_robust.set_initial(T2, T2_guess);
opti_robust.set_initial(T3, T3_guess);
opti_robust.set_initial(T4, T4_guess);
opti_robust.set_initial(T5, T5_guess);
    

% Generate heel-strike map (periodicity for swing vs stance leg + impulsive
% collision constraint) 
% WE DEAL WITH THIS USING A Unscented Transform of the HEELSTRIKE MAP
% q1_min = q1(:,end); q2_min = q2(:,end); q3_min = q3(:,end); q4_min = q4(:,end); q5_min = q5(:,end);
% q1_plus = q1(:,1); q2_plus = q2(:,1); q3_plus = q3(:,1); q4_plus = q4(:,1); q5_plus = q5(:,1);
% dq1_min = dq1(:,end); dq2_min = dq2(:,end); dq3_min = dq3(:,end); dq4_min = dq4(:,end); dq5_min = dq5(:,end);
% dq1_plus = dq1(:,1); dq2_plus = dq2(:,1); dq3_plus = dq3(:,1); dq4_plus = dq4(:,1); dq5_plus = dq5(:,1);
% heelStrike_error = eq_HeelStrike(I1,I2,I3,I4,I5,dq1_min,dq2_min,dq3_min,dq4_min,dq5_min,dq1_plus,dq2_plus,dq3_plus,dq4_plus,dq5_plus,l1,l2,l4,l5,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,q1_min,q2_min,q3_min,q4_min,q5_min,q1_plus,q2_plus,q3_plus,q4_plus,q5_plus)


J = 0;

% Implicit constraints to determine the values of all lifted/slack variables
for k=1:N+1
    % State at mesh point k
    q1k = q1(:,k);     q2k = q2(:,k);     q3k = q3(:,k);     q4k = q4(:,k);     q5k = q5(:,k);
    dq1k = dq1(:,k);   dq2k = dq2(:,k);   dq3k = dq3(:,k);   dq4k = dq4(:,k);   dq5k = dq5(:,k);
    
    % Control/ for mesh k
    ddq1k = ddq1(:,k); ddq2k = ddq2(:,k); ddq3k = ddq3(:,k); ddq4k = ddq4(:,k); ddq5k = ddq5(:,k);
    T1k = T1(:,k);     T2k = T2(:,k);     T3k = T3(:,k);     T4k = T4(:,k);     T5k = T5(:,k);  

    
    % Feedback variables
    refTrajk = refTraj(:,k);
    Kk = K(:,(k-1)*10+1:10*k);
    
    relativeJointPosk = relativeJointPos(q1k,q2k,q3k,q4k,q5k);
    relativeJointVelk = relativeJointVel(dq1k,dq2k,dq3k,dq4k,dq5k);
	
	% Reference trajectory
    opti_robust.subject_to((refTrajk - [relativeJointPosk; relativeJointVelk])./refTraj_scale == 0);
    
    % nominal dynamics
    error = f_eq_SysDyn_Error_Nominal(T1k,T2k,T3k,T4k,T5k,ddq1k,ddq2k,ddq3k,ddq4k,ddq5k,dq1k,dq2k,dq3k,dq4k,dq5k,q1k,q2k,q3k,q4k,q5k);
    opti_robust.subject_to(error./ddq_scale == 0);
	
	% sensitivity of nominal dynamics wrt states
    udxk = udx(:,(k-1)*10 + 1:k*10);
    error_der = f_dynamicsDerivativeError(T1k,T2k,T3k,T4k,T5k,ddq1k,ddq2k,ddq3k,ddq4k,ddq5k,dq1k,dq2k,dq3k,dq4k,dq5k,q1k,q2k,q3k,q4k,q5k,refTrajk,Kk,[dq1k;dq2k;dq3k;dq4k;dq5k],udxk);
    opti_robust.subject_to(error_der./udx_scale(1:50)' == 0);
    
	% sensitivity of nominal dynamics wrt motor noise
    udwk = udw(:,(k-1)*5 + 1:k*5);
    error_der = f_dynamicsDerivativeWError(T1k,T2k,T3k,T4k,T5k,ddq1k,ddq2k,ddq3k,ddq4k,ddq5k,dq1k,dq2k,dq3k,dq4k,dq5k,q1k,q2k,q3k,q4k,q5k,refTrajk,Kk,[dq1k;dq2k;dq3k;dq4k;dq5k],udwk);
    opti_robust.subject_to(error_der./udw_scale(1:25)' == 0);
    
    % sensitivity of nominal dynamics wrt sensory noise
    udwSk = udwS(:,(k-1)*10 + 1:k*10);
    error_der = f_dynamicsDerivativeWSError(T1k,T2k,T3k,T4k,T5k,ddq1k,ddq2k,ddq3k,ddq4k,ddq5k,dq1k,dq2k,dq3k,dq4k,dq5k,q1k,q2k,q3k,q4k,q5k,refTrajk,Kk,[dq1k;dq2k;dq3k;dq4k;dq5k],udwSk);
    opti_robust.subject_to(error_der./udwS_scale(1:50)' == 0);
    

    % Cost function contributions of the joint torques squared
    J = J + (T1k.^2 + T2k.^2 + T3k.^2 + T4k.^2 + T5k.^2)*dt;% 
    
    % Joint locations in x-y plane
    P_J = JointPos(l1,l2,l3,l4,l5,q1k,q2k,q3k,q4k,q5k);
    % Impose that swing foot does not penetrate ground (I think this will get overruled by the 'stochastic' foot clearance constraint)
    opti_robust.subject_to(P_J(10) > -1e-8);
        
end

% Implicit integration of the nominal and lyapunov dynamics
for k=1:N

	%%% Nominal dynamics
    % State at mesh point k
    q1k = q1(:,k);     q2k = q2(:,k);     q3k = q3(:,k);     q4k = q4(:,k);     q5k = q5(:,k);
    dq1k = dq1(:,k);   dq2k = dq2(:,k);   dq3k = dq3(:,k);   dq4k = dq4(:,k);   dq5k = dq5(:,k);
    
	% State at mesh point k+1
    q1k_plus = q1(:,k+1);     q2k_plus = q2(:,k+1);     q3k_plus = q3(:,k+1);     q4k_plus = q4(:,k+1);     q5k_plus = q5(:,k+1);
    dq1k_plus = dq1(:,k+1);   dq2k_plus = dq2(:,k+1);   dq3k_plus = dq3(:,k+1);   dq4k_plus = dq4(:,k+1);   dq5k_plus = dq5(:,k+1);
	
    % Derivative at for mesh k and k + 1
    ddq1k = ddq1(:,k); ddq2k = ddq2(:,k); ddq3k = ddq3(:,k); ddq4k = ddq4(:,k); ddq5k = ddq5(:,k);
    ddq1k_plus = ddq1(:,k+1); ddq2k_plus = ddq2(:,k+1); ddq3k_plus = ddq3(:,k+1); ddq4k_plus = ddq4(:,k+1); ddq5k_plus = ddq5(:,k+1);
        
    % Collect state (at k and k+1)
    Xk = [q1k; q2k; q3k; q4k; q5k; dq1k; dq2k; dq3k; dq4k; dq5k];
    Xk_next = [q1k_plus; q2k_plus; q3k_plus; q4k_plus; q5k_plus; dq1k_plus; dq2k_plus; dq3k_plus; dq4k_plus; dq5k_plus];
    
    % Collect state derivative (at k and k+1)
    Uk = [dq1k; dq2k; dq3k; dq4k; dq5k; ddq1k; ddq2k; ddq3k; ddq4k; ddq5k];
    Uk_plus = [dq1k_plus; dq2k_plus; dq3k_plus; dq4k_plus; dq5k_plus; ddq1k_plus; ddq2k_plus; ddq3k_plus; ddq4k_plus; ddq5k_plus];
    
    % Integration (trapezoidal)
    opti_robust.subject_to((Xk_next - (Xk + (Uk + Uk_plus)*dt/2))./[q_scale;dq_scale] == 0);
  
	%%% Lyapunov dynamics
	
	% Gains
    Kk = K(:,(k-1)*10+1:10*k);
      
	% Dynamic sensitivities	  
    udxk = udx(:,(k-1)*10 + 1:k*10);
    udwk = udw(:,(k-1)*5 + 1:k*5);
    udwSk = udwS(:,(k-1)*10 + 1:k*10);
    udzk = udx(:,k*10 + 1 : (k+1)*10);

	% Stuff related to Joris' adaptation to the integration scheme
    Mk = M(:,(k-1)*10 + 1:k*10);
    dGdz_ = dGdz(udzk,dt);
    dGdx_ = dGdx(udxk,dt);
    dGdw_ = dGdw(udwk,dt);
    dGdwS_ = dGdw(udwSk,dt);
    opti_robust.subject_to(Mk*dGdz_ - eye(10) == 0);
    
	% Covariance matrix at k
    Lk = L(:,k);
    Lmatk = tril(ones(10)).*Lk(indicesP);
    Pmatk = Lmatk*Lmatk';

	% Covariance matrix at k + 1 based on state variables
    Lk_plus = L(:,k+1);
    Lmatk_plus = tril(ones(10)).*Lk_plus(indicesP);
    Pmatk_plus_ = Lmatk_plus*Lmatk_plus';
    Pveck_plus = Pmatk_plus_(vecindicesP);
 
	% Covariance matrix at k + 1 based on integration step
    Pmatk_plus = Mk*(dGdx_*Pmatk*dGdx_' + dGdw_*motorNoise_discreteVAR*eye(5)*dGdw_'  + dGdwS_*(sensoryNoise_discreteVAR.*eye(10))*dGdwS_')*Mk';
    Pk_plus = Pmatk_plus(vecindicesP);
	
	% Constraint to set these equal
    opti_robust.subject_to((Pk_plus - Pveck_plus)./Pscale(vecindicesP) == 0);   
    
	% Add expected effort (motor corrections to the cost function)
    expected_effortk = sum(diag((Kk*feedbackTransform)*Pmatk*(Kk*feedbackTransform)')) + sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'));
    J = J + expected_effortk*dt; % + 0*1e2*sumsqr(diag(Pmatk));
    
    % Foot clearance during midstance
    if k > 0.1*N && k < 0.9*N
        P_J = JointPos(l1,l2,l3,l4,l5,q1k,q2k,q3k,q4k,q5k);
        footClearance = P_J(10);
        dfootClearance_dX = f_dfootClearance_dX_MX(q1k,q2k,q3k,q4k,q5k);
        opti_robust.subject_to((footClearance^2 - 9*dfootClearance_dX*Pmatk(1:5,1:5)*dfootClearance_dX')*1e3 > 0);
    end
    
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Constrain the contact variability
% The heel-strike map is a non-linear function that maps the segment
% angles and velocities from pre -to post heelstrike. (Angles stay the same, but velocities change instantaneously)
% We use the Unscented Transform to estimate the state distributions post heel strike, knowing the state distributions pre heelstrike.
%% UT of contact %%%
nStates = 10; % angles + angular velocities
nNoiseSources = 0; % no additional noise sources in the this non-linear function, note that this is an instantaneous mapping, not an integration over time where additive noise can corrupt behaviour
nTOT = nStates + nNoiseSources;
% nTOT = 0;

% Tuning of the UT parameters
alpha = 1; % --> determines the spread of the sigma points -- influence on c! a small value means a small spread around the mean in sigma selection. Has an influence on selection of the posterior covariance
kappa = 3-nTOT; % Scales the spread of the sigma points as well, often 3-n is chosen, but this can generate some problems with positive definitness
beta = 2; % Is a parameter to incorporate prior knowledge on distribution, only affects the weights to compose the posterior covariance matrix
% If alpha = 1 and kappa = 0 you get the basic implementation of the UKF.
% Note that Julier commented in the paper (unscented ...) that non-positive
% weights for predicted covariance can lead to non-positive definitness
kappa = -6; % We adapt kappa to the most "extreme" value that does not violate positive weights.
lambda = alpha^2*(nTOT + kappa) - nTOT;

% Setting the weights to compute UT sigmapoints
W_0_M = lambda/(nTOT+lambda); % Weight on the nominal value to determine distribution mean
W_i_M = 1/(2*(nTOT+lambda)); % Weight on the other values (sampled sigma points) to determine distribution mean
W_0_C = lambda/(nTOT+lambda) + 1 - alpha^2 + beta;  % Weight on the nominal value to determine distribution covariance
W_i_C = 1/(2*(nTOT+lambda)); % Weight on the other values (sampled sigma points) to determine distribution covariance

% Put all weights together in vector
WeightVec_M = [W_0_M W_i_M*ones(1,2*(nTOT))];
WeightVec_C = [W_0_C W_i_C*ones(1,2*(nTOT))];

% This parameter determines the spread of the samples (~how many standard
% deviations around mean)
c = sqrt(nTOT+lambda);

% L are lower triangular matrices: L*L' = covariance-matrix ==> L is the
% square root of the covariance matrix. It will serve to perform sampling
% of the sigma points.
L_precontact = Lscale_vec.*opti_robust.variable(55,1); % L-matrix pre contact
opti_robust.subject_to(L_precontact(varianceIndices) > 0);

Lguess_precontact = result.L_precontact_sol;
opti_robust.set_initial(L_precontact,Lguess_precontact);

L_postcontact = Lscale_vec.*opti_robust.variable(55,1); % L-matrix post contact
opti_robust.subject_to(L_postcontact(varianceIndices) > 0);
opti_robust.set_initial(L_postcontact,result.L_postcontact_sol);

% Sigma points post contact. We use 2*nTOT+1 sigma points to estimate
% distribution from
sigma_postcontact = opti_robust.variable(10,2*nTOT + 1);
opti_robust.set_initial(sigma_postcontact,result.sigma_postcontact_sol);

% Estimate the 
mean_precontact_guess = [result.q1_sol(:,end); result.q2_sol(:,end); result.q3_sol(:,end); result.q4_sol(:,end); result.q5_sol(:,end); result.dq1_sol(:,end); result.dq2_sol(:,end); result.dq3_sol(:,end); result.dq4_sol(:,end); result.dq5_sol(:,end)];
Lguess_mat_precontact = Lguess_precontact(indicesP);
sigma_precontact_guess = [mean_precontact_guess      mean_precontact_guess + c*Lguess_mat_precontact      mean_precontact_guess - c*Lguess_mat_precontact];


    

% Constraint the L matrix precontact to be equal to the L-matrix at the end
% of the simulation. 
Lk = L(:,k+1);
opti_robust.subject_to((Lk - L_precontact)./(Lscale_vec) == 0);  

% Generate sigma points pre-contact
L_precontact_mat = tril(ones(10,10)).*L_precontact(indicesP);
opti_robust.subject_to(diag(L_precontact_mat) > 0);  
A_precontact = c*L_precontact_mat;
Xk_precontact = Xk_next; % state variable at last point of the simulation
sigma_precontact = [Xk_precontact Xk_precontact + A_precontact Xk_precontact - A_precontact];

% Compute the sigma points post contact from the sigma points pre-contact
% by applying the non-linear heelstrike equation
eq_heelstrikeError = eq_HeelStrike(I1,I2,I3,I4,I5,sigma_precontact(6,:),sigma_precontact(7,:),sigma_precontact(8,:),sigma_precontact(9,:),sigma_precontact(10,:),sigma_postcontact(6,:),sigma_postcontact(7,:),sigma_postcontact(8,:),sigma_postcontact(9,:),sigma_postcontact(10,:),l1,l2,l4,l5,lc1,lc2,lc3,lc4,lc5,m1,m2,m3,m4,m5,...
                                    sigma_precontact(1,:),sigma_precontact(2,:),sigma_precontact(3,:),sigma_precontact(4,:),sigma_precontact(5,:)...
                                    ,sigma_postcontact(1,:),sigma_postcontact(2,:),sigma_postcontact(3,:),sigma_postcontact(4,:),sigma_postcontact(5,:));
opti_robust.subject_to(eq_heelstrikeError == 0);                                
                                       
% Compute from the sigma points post contact the estimated post contact mean
mean_postcontact = sigma_postcontact*WeightVec_M';
% Impose this mean to be equal to the initial state of the simulation (state continuity!)
opti_robust.subject_to(mean_postcontact - [q1(:,1); q2(:,1); q3(:,1); q4(:,1); q5(:,1); dq1(:,1); dq2(:,1); dq3(:,1); dq4(:,1); dq5(:,1);] == 0);
    
% Compute from the sigma points post contact the estimated post contact covariance
Y1k = sigma_postcontact - mean_postcontact;
P_postcontact_mat = Y1k*diag(WeightVec_C)*Y1k' + 1e-8*eye(10); % Add small identity noise to ensure positive definitness should uncertainty be very low (around machine precision)

% Set the post contact covariance to be equal to L*L' post contact
L_postcontact_mat = tril(ones(10,10)).*L_postcontact(indicesP);
P_postcontact_mat_estimated = L_postcontact_mat*L_postcontact_mat';
opti_robust.subject_to((P_postcontact_mat_estimated(vecindicesP) - P_postcontact_mat(vecindicesP))./Pscale_vec == 0);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional constraints and contributions
% Add motor correction at the very last mesh point. 
Kk = K(:,(k)*10+1:10*(k+1));
expected_effortk = sum(diag((Kk*feedbackTransform)*Pmatk_plus_*(Kk*feedbackTransform)')) +  sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'));
J = J + expected_effortk*dt;

% Impose step length
JointPosFinal = JointPos(l1,l2,l3,l4,l5,q1(:,end),q2(:,end),q3(:,end),q4(:,end),q5(:,end));
opti_robust.subject_to(JointPosFinal(9:10,:) - [D;0] == 0);

% Impose that simulation start and end is at 'toe-off' and 'heel-strike' (positive and negative ankle y-velocities respectively)
JointVelInit = JointVel(dq1(:,1),dq2(:,1),dq3(:,1),dq4(:,1),dq5(:,1),l1,l2,l3,l4,l5,q1(:,1),q2(:,1),q3(:,1),q4(:,1),q5(:,1));
JointVelFinal = JointVel(dq1(:,end),dq2(:,end),dq3(:,end),dq4(:,end),dq5(:,end),l1,l2,l3,l4,l5,q1(:,end),q2(:,end),q3(:,end),q4(:,end),q5(:,end));
opti_robust.subject_to(JointVelInit(10) > 0);
opti_robust.subject_to(JointVelFinal(10) < 0);

% Generate seperate variables that represent the variance and covariance at
% the beginning and end of the simulation. Constrain them to avoid the
% optimization to "run-off" to unrealistic regions of the variable space
Pscale_diag = diag(Pscale);

initVarPos = Pscale_diag(1:5).*opti_robust.variable(5,1);
opti_robust.subject_to(10 > initVarPos > 1e-5);
opti_robust.set_initial(initVarPos,result.initVarPos_sol);

initVarVel = Pscale_diag(6:10).*opti_robust.variable(5,1);
opti_robust.subject_to(10 > initVarVel > 1e-5);
opti_robust.set_initial(initVarVel,result.initVarVel_sol);

initCovar = Pscale_vec(covarianceIndices).*opti_robust.variable(45,1); 
opti_robust.set_initial(initCovar,result.initCovar_sol);

% Set these new variables equal to the initial distributions defined by L
L_init_vec = L(:,1);
L_init_matk = tril(ones(10)).*L_init_vec(indicesP);
P_init_matk = L_init_matk*L_init_matk';
P_init_vec = P_init_matk(vecindicesP);
opti_robust.subject_to((P_init_vec(varianceIndices(1:5),1) - initVarPos)./Pscale_diag(1:5) == 0);
opti_robust.subject_to((P_init_vec(varianceIndices(6:10),1) - initVarVel)./Pscale_diag(6:10) == 0);
opti_robust.subject_to((P_init_vec(covarianceIndices,1) - initCovar)./Pscale_vec(covarianceIndices) == 0);

P_helper_vec = zeros(55,1);

% Make sure that the post-contact distributions are continuous and cyclic.
% P_postcontact = Pinitial.
L_final_vec = L(:,end);
L_final_matk = tril(ones(10)).*L_final_vec(indicesP);
P_final_matk = L_final_matk*L_final_matk';
P_finalRel_matk = feedbackTransform*P_final_matk*feedbackTransform';
P_final_vec = P_final_matk(vecindicesP);
P_finalRel_vec = P_finalRel_matk(vecindicesP);

P_postcontact_estimated = P_postcontact_mat_estimated(vecindicesP);
opti_robust.subject_to((P_postcontact_estimated(varianceIndices) - [initVarPos;initVarVel])./Pscale_diag == 0);
opti_robust.subject_to((P_postcontact_estimated(covarianceIndices) - [initCovar])./Pscale_vec(covarianceIndices) == 0);

% Define cost
opti_robust.minimize(1e-3*J); % Scale to be in order ~1

% Create an NLP solver
optionssol.ipopt.linear_solver = 'mumps';
% optionssol.ipopt.print_level = 6;

optionssol.ipopt.tol = 1e-5;

optionssol.ipopt.constr_viol_tol = 1e-6;

optionssol.ipopt.max_iter = 1e5;
optionssol.ipopt.nlp_scaling_method = 'none';
optionssol.ipopt.hessian_approximation = 'limited-memory';
optionssol.ipopt.mu_strategy = 'adaptive';
optionssol.ipopt.bound_push = 1e-5;
optionssol.ipopt.required_infeasibility_reduction = 0.999999;
% optionssol.ipopt.print_level = 6;
opti_robust.solver('ipopt',optionssol);

diary(diaryName);
% sol = opti_robust.solve();
output = solve_NLPSOL(opti_robust,optionssol);
diary off;
index = 1;
clear result;
q1_sol = q_scale(1).*output(index:index + N)'; index = index + N + 1; result.q1_sol = q1_sol;
q2_sol = q_scale(2).*output(index:index + N)'; index = index + N + 1; result.q2_sol = q2_sol;
q3_sol = q_scale(3).*output(index:index + N)'; index = index + N + 1; result.q3_sol = q3_sol;
q4_sol = q_scale(4).*output(index:index + N)'; index = index + N + 1; result.q4_sol = q4_sol;
q5_sol = q_scale(5).*output(index:index + N)'; index = index + N + 1; result.q5_sol = q5_sol;

dq1_sol = dq_scale(1).*output(index:index + N)'; index = index + N + 1; result.dq1_sol = dq1_sol;
dq2_sol = dq_scale(2).*output(index:index + N)'; index = index + N + 1; result.dq2_sol = dq2_sol;
dq3_sol = dq_scale(3).*output(index:index + N)'; index = index + N + 1; result.dq3_sol = dq3_sol;
dq4_sol = dq_scale(4).*output(index:index + N)'; index = index + N + 1; result.dq4_sol = dq4_sol;
dq5_sol = dq_scale(5).*output(index:index + N)'; index = index + N + 1; result.dq5_sol = dq5_sol;

ddq1_sol = ddq_scale(1).*output(index:index + N)'; index = index + N + 1; result.ddq1_sol = ddq1_sol;
ddq2_sol = ddq_scale(2).*output(index:index + N)'; index = index + N + 1; result.ddq2_sol = ddq2_sol;
ddq3_sol = ddq_scale(3).*output(index:index + N)'; index = index + N + 1; result.ddq3_sol = ddq3_sol;
ddq4_sol = ddq_scale(4).*output(index:index + N)'; index = index + N + 1; result.ddq4_sol = ddq4_sol;
ddq5_sol = ddq_scale(5).*output(index:index + N)'; index = index + N + 1; result.ddq5_sol = ddq5_sol;

T1_sol = T_scale(1).*output(index:index + N)'; index = index + N + 1; result.T1_sol = T1_sol;
T2_sol = T_scale(2).*output(index:index + N)'; index = index + N + 1; result.T2_sol = T2_sol;
T3_sol = T_scale(3).*output(index:index + N)'; index = index + N + 1; result.T3_sol = T3_sol;
T4_sol = T_scale(4).*output(index:index + N)'; index = index + N + 1; result.T4_sol = T4_sol;
T5_sol = T_scale(5).*output(index:index + N)'; index = index + N + 1; result.T5_sol = T5_sol;


refTraj_sol = refTraj_scale.*reshape(output(index:index + 10*(N+1) - 1),10,N+1); index = index + 10*(N + 1); result.refTraj_sol = refTraj_sol;

K_sol = repmat(K_scale,1,N+1).*reshape(output(index:index + 5*10*(N+1) - 1),5,10*(N+1)); index = index + 5*10*(N + 1); result.K_sol = K_sol;

udx_sol = repmat(udx_scale,1,N+1).*reshape(output(index: index + 10*10*(N+1) - 1),10,10*(N+1)); index = index + 10*10*(N + 1); result.udx_sol = udx_sol;

M_sol = reshape(output(index: index + 10*10*N - 1),10,10*N); index = index + 10*10*N; result.M_sol = M_sol;

L_sol = Lscale_vec.*reshape(output(index: index + 55*(N+1) - 1),55,N+1); index = index + 55*(N + 1); result.L_sol = L_sol;

udw_sol = repmat(udw_scale,1,N+1).*reshape(output(index: index + 10*5*(N+1) - 1),10,5*(N+1)); index = index + 10*5*(N + 1); result.udw_sol = udw_sol;

udwS_sol =  repmat(udwS_scale,1,N+1).*reshape(output(index: index + 10*10*(N+1) - 1),10,10*(N+1));  index = index + 10*10*(N + 1); result.udwS_sol = udwS_sol;

L_precontact_sol = Lscale(vecindicesP).*output(index: index + 55 - 1); index = index + 55; result.L_precontact_sol = L_precontact_sol;

L_postcontact_sol = Lscale(vecindicesP).*output(index: index + 55 - 1); index = index + 55; result.L_postcontact_sol = L_postcontact_sol;

sigma_postcontact_sol = reshape(output(index: index + 10*21 - 1),10,21); index = index + 10*21; result.sigma_postcontact_sol = sigma_postcontact_sol;

initVarPos_sol = Pscale_diag(1:5).*output(index:index + 5 - 1); index = index + 5; result.initVarPos_sol = initVarPos_sol;

initVarVel_sol = Pscale_diag(6:10).*output(index:index + 5 - 1); index = index + 5; result.initVarVel_sol = initVarVel_sol;

initCovar_sol = Pscale_vec(covarianceIndices).*output(index:index + 45 - 1); index = index + 45; result.initCovar_sol = initCovar_sol;

% sol = opti_robust.solve();
% diary off

% q1_sol = sol.value(q1); result.q1_sol = q1_sol;
% q2_sol = sol.value(q2); result.q2_sol = q2_sol;
% q3_sol = sol.value(q3); result.q3_sol = q3_sol;
% q4_sol = sol.value(q4); result.q4_sol = q4_sol;
% q5_sol = sol.value(q5); result.q5_sol = q5_sol;
% 
% dq1_sol = sol.value(dq1); result.dq1_sol = dq1_sol;
% dq2_sol = sol.value(dq2); result.dq2_sol = dq2_sol;
% dq3_sol = sol.value(dq3); result.dq3_sol = dq3_sol;
% dq4_sol = sol.value(dq4); result.dq4_sol = dq4_sol;
% dq5_sol = sol.value(dq5); result.dq5_sol = dq5_sol;
% 
% T1_sol = sol.value(T1); result.T1_sol = T1_sol;
% T2_sol = sol.value(T2); result.T2_sol = T2_sol;
% T3_sol = sol.value(T3); result.T3_sol = T3_sol;
% T4_sol = sol.value(T4); result.T4_sol = T4_sol;
% T5_sol = sol.value(T5); result.T5_sol = T5_sol;
% 
% ddq1_sol = sol.value(ddq1); result.ddq1_sol = ddq1_sol;
% ddq2_sol = sol.value(ddq2); result.ddq2_sol = ddq2_sol;
% ddq3_sol = sol.value(ddq3); result.ddq3_sol = ddq3_sol;
% ddq4_sol = sol.value(ddq4); result.ddq4_sol = ddq4_sol;
% ddq5_sol = sol.value(ddq5); result.ddq5_sol = ddq5_sol;
% 
% refTraj_sol = sol.value(refTraj); result.refTraj_sol = refTraj_sol;
% K_sol = sol.value(K); result.K_sol = K_sol;
% 
% L_sol = sol.value(L); result.L_sol = L_sol;
% 
% initVarPos_sol = sol.value(initVarPos); result.initVarPos_sol = initVarPos_sol;
% initVarVel_sol = sol.value(initVarVel); result.initVarVel_sol = initVarVel_sol;
% 
% udx_sol = sol.value(udx); result.udx_sol = udx_sol;
% udw_sol = sol.value(udw); result.udw_sol = udw_sol;
% M_sol = sol.value(M); result.M_sol = M_sol;
% result.L_postcontact_sol = sol.value(L_postcontact); L_postcontact_sol = sol.value(L_postcontact); 


% Verify that P matrix is always positive definite
cost_expectedEffort = 0;
for k = 1:N+1
    Lvec_sol = L_sol(:,k);
    Lmat_sol = tril(ones(10)).*Lvec_sol(indicesP);
    Pmat_sol = Lmat_sol*Lmat_sol';
    Pvec_sol(:,k) = Pmat_sol(vecindicesP);
    Kk = K_sol(:,(k-1)*10+1:10*k);
    cost_expectedEffort = cost_expectedEffort + sum(diag((Kk*feedbackTransform)*Pmat_sol*(Kk*feedbackTransform)'))*dt   +  sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'))*dt;
    T_std(:,k) = sqrt(diag((Kk*feedbackTransform)*Pmat_sol*(Kk*feedbackTransform)'))  +  sum(diag(Kk*(sensoryNoise_discreteVAR.*eye(10))*Kk'));
    q_std(:,k) = sqrt(diag(Pmat_sol(1:5,1:5)));
    dq_std(:,k) = sqrt(diag(Pmat_sol(6:10,6:10)));

    [~,flag] = chol(Pmat_sol);
    flag
end

result.P_sol = Pvec_sol;
result.J_torque = (sumsqr(T1_sol) + sumsqr(T2_sol) + sumsqr(T3_sol) + sumsqr(T4_sol) + sumsqr(T5_sol))*dt;
result.J_expectedEffort = cost_expectedEffort;

[ipoptStats.CPU_IPOPT,ipoptStats.CPU_NLP,ipoptStats.NIter,ipoptStats.Cost,ipoptStats.Dual_inf,ipoptStats.Cons_Viol,ipoptStats.Compl,ipoptStats.Error_NLP,ipoptStats.OptSol] = readDiary(diaryName);
result.ipoptStats = ipoptStats;
result.motorNoise_continuousVAR = motorNoise_continuousVAR;
result.sensoryNoise_continuousVAR = sensoryNoise_continuousVAR;

save(saveName,'result')



